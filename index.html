<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>QuantumClash 3D: Titan Protocol - Customization Edition</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  body { margin:0; overflow:hidden; background:#000; font-family:'Orbitron', sans-serif; color:white; user-select:none; }
  
  /* --- CINEMATIC HUD --- */
  #game-ui { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:none; 
    box-shadow: inset 0 0 100px rgba(0,0,0,0.8); z-index: 10; }
  
  .hud-top { 
    position: absolute; top:0; width:100%; height: 80px; 
    display:flex; justify-content:space-between; align-items: center; 
    padding:0 40px; box-sizing:border-box; 
    background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
  }
  
  .player-hud { display:flex; flex-direction:column; width: 250px; }
  .p1-label { color:#0ff; text-shadow: 0 0 10px #0ff; font-weight:700; margin-bottom:5px; font-size:0.9rem; }
  .p2-label { color:#f00; text-shadow: 0 0 10px #f00; font-weight:700; margin-bottom:5px; text-align:right; font-size:0.9rem; }
  
  .hp-bar-bg { width:100%; height:10px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.3); transform: skewX(-20deg); overflow:hidden; }
  .hp-bar-fill { height:100%; width:100%; transition:width 0.2s cubic-bezier(0.1, 0.7, 1.0, 0.1); }
  /* Dynamic class for player 1 customization */
  .fill-p1 { background: linear-gradient(90deg, #00ffff, #0088ff); box-shadow: 0 0 15px #00ffff; }
  
  .fill-p2 { background: linear-gradient(90deg, #ff0000, #ff8800); box-shadow: 0 0 15px #ff0000; }
  .fill-boss { background: linear-gradient(90deg, #800000, #ff0000); box-shadow: 0 0 20px #ff0000; }

  #boss-hud-container {
    position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
    width: 400px; text-align: center; display: none; animation: slideDown 0.5s ease-out;
  }
  @keyframes slideDown { from { top: -50px; opacity: 0; } to { top: 60px; opacity: 1; } }
  .boss-name { color: #ff3333; font-weight: 900; letter-spacing: 4px; text-shadow: 0 0 10px red; margin-bottom: 5px; }
  
  #center-notify { position:absolute; top:40%; width:100%; text-align:center; font-size:3rem; 
    text-shadow: 0 0 30px rgba(255,255,255,0.8); letter-spacing: 10px; 
    opacity:0; transition: opacity 0.5s; transform: scale(1); pointer-events: none;}
  
  #radar-box { position:absolute; bottom:30px; right:30px; width:150px; height:150px; 
    border: 2px solid rgba(0, 255, 0, 0.5); border-radius: 50%; 
    background: radial-gradient(circle, rgba(0,50,0,0.4) 0%, rgba(0,0,0,0.8) 100%);
    box-shadow: 0 0 20px rgba(0,255,0,0.2); overflow:hidden; backdrop-filter: blur(2px);
  }
  #radar-canvas { width:100%; height:100%; mix-blend-mode: screen; }

  #level-ind { position:absolute; bottom:30px; left:30px; color:#fff; font-size:1.2rem; text-shadow:0 0 10px white; }

  #producer-credit {
    position: absolute; bottom: 10px; width: 100%; text-align: center;
    color: rgba(0, 255, 255, 0.6); font-size: 0.8rem; letter-spacing: 2px;
    text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
    pointer-events: none; z-index: 20;
  }

  #cam-toggle-btn {
    pointer-events: auto;
    background: rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: #0ff;
    padding: 8px 16px;
    font-family: 'Orbitron', sans-serif;
    font-size: 0.8rem;
    letter-spacing: 1px;
    cursor: pointer;
    transition: 0.3s;
    text-transform: uppercase;
    clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
  }
  #cam-toggle-btn:hover {
    background: rgba(0, 255, 255, 0.2);
    box-shadow: 0 0 15px #0ff;
    border-color: #0ff;
    color: #fff;
  }
  
  /* --- MENU SCREEN --- */
  #menu-screen { 
    position:fixed; top:0; left:0; width:100%; height:100%; 
    background: rgba(0, 0, 0, 0.3); 
    backdrop-filter: blur(4px); 
    z-index:100; 
    display:flex; flex-direction:column; align-items:center; justify-content:center; pointer-events:auto; 
    transition: opacity 0.5s;
  }
  
  h1 { font-size:5rem; margin:0; background: linear-gradient(to right, #0ff, #f0f); -webkit-background-clip: text; color:transparent; text-shadow: 0 0 50px rgba(0,255,255,0.5); text-align: center;}
  
  .menu-btn {
    background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); 
    color: #fff; padding: 15px 40px; margin: 10px; font-size: 1.2rem; font-family: inherit; 
    cursor: pointer; transition: 0.3s; text-transform: uppercase; letter-spacing: 4px;
    backdrop-filter: blur(5px); clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
  }
  .menu-btn:hover { background: #0ff; color: #000; border-color: #0ff; box-shadow: 0 0 30px #0ff; transform: translateY(-3px); }
  .menu-btn:disabled { opacity: 0.5; cursor: not-allowed; pointer-events: none; }

  .level-select { display:flex; gap:15px; margin-bottom:30px; }
  .level-opt { padding:8px 15px; border:1px solid #555; cursor:pointer; opacity:0.5; transition:0.3s; font-size: 0.9rem; }
  .level-opt:hover, .level-opt.active { opacity:1; border-color:#0ff; background:rgba(0,255,255,0.1); box-shadow:0 0 15px #0ff; }

  /* --- CUSTOMIZATION UI --- */
  #custom-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(10px);
    z-index: 150;
    display: none; /* Hidden by default */
    pointer-events: auto;
  }

  .custom-layout {
    display: flex; width: 100%; height: 100%;
  }

  .custom-preview {
    flex: 1; /* Left side: 3D View */
    position: relative;
    background: radial-gradient(circle at center, #111, #000);
  }

  .custom-controls {
    width: 400px; /* Right side: UI */
    background: rgba(10, 10, 15, 0.95);
    border-left: 2px solid #333;
    padding: 20px;
    box-sizing: border-box;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  .custom-header {
    display: flex; justify-content: space-between; align-items: center;
    border-bottom: 1px solid #333; padding-bottom: 10px; margin-bottom: 10px;
  }

  .custom-title { font-size: 1.5rem; color: #0ff; text-transform: uppercase; letter-spacing: 2px; }
  
  .custom-section { border: 1px solid #333; padding: 15px; border-radius: 5px; }
  .custom-section h3 { margin: 0 0 15px 0; font-size: 1rem; color: #aaa; text-transform: uppercase; letter-spacing: 1px; }

  /* Form Elements */
  .option-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
  .option-label { font-size: 0.8rem; color: #ddd; }
  
  .color-swatch-group { display: flex; gap: 5px; }
  .color-swatch {
    width: 25px; height: 25px; border: 1px solid #555; cursor: pointer; transition: 0.2s;
  }
  .color-swatch:hover { transform: scale(1.1); }
  .color-swatch.active { border: 2px solid #fff; box-shadow: 0 0 10px white; }

  select, input[type="range"] {
    background: #222; border: 1px solid #444; color: #fff;
    padding: 5px; font-family: 'Orbitron'; outline: none;
  }
  select { width: 150px; }
  
  .back-btn {
    background: #555; color: white; border: none; padding: 5px 15px; font-family: inherit; cursor: pointer;
  }

  .action-btns { margin-top: auto; display: flex; gap: 10px; }
  .start-btn { flex: 1; background: #0f0; color: #000; border: none; padding: 15px; font-size: 1.2rem; font-weight: bold; cursor: pointer; text-transform: uppercase; clip-path: polygon(5% 0, 100% 0, 100% 100%, 0 100%, 0 20%); }
  .start-btn:hover { background: #0ff; box-shadow: 0 0 20px #0ff; }

</style>

<!-- Import Map -->
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>
</head>
<body>

<!-- MENU -->
<div id="menu-screen">
  <h1>QUANTUM CLASH<br><span style="font-size:2rem; color:#fff;">TITAN PROTOCOL</span></h1>
  
  <div class="level-select">
    <div class="level-opt active" onclick="setLevel(0, this)">NEBULA</div>
    <div class="level-opt" onclick="setLevel(1, this)">CYBER CITY</div>
    <div class="level-opt" onclick="setLevel(2, this)">ASTEROID</div>
  </div>
  
  <button id="btn-customize" class="menu-btn" onclick="openCustomize()" disabled>CUSTOMIZE</button>
  <button class="menu-btn" onclick="startGame(1)">1 PLAYER</button>
  <button class="menu-btn" onclick="startGame(2)">2 PLAYER CO-OP</button>
  
  <div style="margin-top:20px; color:#ccc; font-size:0.8rem; text-shadow:0 0 5px black; text-align:center;">
    WASD to Move | SPACE to Shoot (P1)<br>
    ARROWS to Move | ENTER to Shoot (P2)<br>
    <span style="color:#ff5555;">WARNING: Boss spawns at 500 Points</span>
  </div>
</div>

<!-- CUSTOMIZATION SCREEN -->
<div id="custom-screen">
  <div class="custom-layout">
    <div class="custom-preview" id="custom-preview-container">
        <!-- 3D Canvas renders here -->
        <div style="position:absolute; top:20px; left:20px; color:#0ff; font-weight:bold;">PREVIEW MODE</div>
        <div style="position:absolute; bottom:20px; width:100%; text-align:center; color:#aaa; font-size:0.8rem;">
            Drag to Rotate | Scroll to Zoom
        </div>
    </div>
    <div class="custom-controls">
        <div class="custom-header">
            <div class="custom-title">Loadout Config</div>
            <button class="back-btn" onclick="closeCustomize()">BACK</button>
        </div>

        <!-- 1. Body & Material -->
        <div class="custom-section">
            <h3>1. Visual Appearance</h3>
            
            <div class="option-row">
                <span class="option-label">Armor Color</span>
                <div class="color-swatch-group" id="swatch-armor">
                    <!-- Generated via JS -->
                </div>
            </div>

            <div class="option-row">
                <span class="option-label">Neon Glow</span>
                <div class="color-swatch-group" id="swatch-neon">
                    <!-- Generated via JS -->
                </div>
            </div>

            <div class="option-row">
                <span class="option-label">Material</span>
                <select id="opt-material" onchange="updatePreview()">
                    <option value="metal">Standard Metal</option>
                    <option value="holographic">Holographic (Wireframe)</option>
                    <option value="matte">Matte Flat</option>
                </select>
            </div>

            <div class="option-row">
                <span class="option-label">Armor Bulk</span>
                <input type="range" id="opt-bulk" min="0.8" max="1.5" step="0.1" value="1.0" oninput="updatePreview()">
            </div>
        </div>

        <!-- 2. Head & Face -->
        <div class="custom-section">
            <h3>2. Head & Helmet</h3>
            <div class="option-row">
                <span class="option-label">Animation / Pose</span>
                <select id="opt-anim" onchange="updatePreview()">
                    <option value="Idle">Battle Ready (Idle)</option>
                    <option value="Walking">Patrol (Walk)</option>
                    <option value="Running">Assault (Run)</option>
                    <option value="Dance">Victory (Dance)</option>
                    <option value="Sitting">Relaxed (Sit)</option>
                    <option value="Death">Defeat</option>
                </select>
            </div>
            <div class="option-row">
                <span class="option-label">Crown Type</span>
                <select id="opt-crown" onchange="updatePreview()">
                    <option value="none">None</option>
                    <option value="horns">Demon Horns</option>
                    <option value="halo">Holographic Halo</option>
                    <option value="antenna">Tech Antenna</option>
                </select>
            </div>
        </div>

        <!-- 3. Limbs & Extras -->
        <div class="custom-section">
            <h3>3. Accessories</h3>
            <div class="option-row">
                <span class="option-label">Backpack</span>
                <select id="opt-jetpack" onchange="updatePreview()">
                    <option value="none">None</option>
                    <option value="thrusters">Ion Thrusters</option>
                    <option value="wings">Solar Wings</option>
                    <option value="tanks">Oxygen Tanks</option>
                </select>
            </div>
            <div class="option-row">
                <span class="option-label">Shoulder Drones</span>
                <select id="opt-drones" onchange="updatePreview()">
                    <option value="none">None</option>
                    <option value="sentry">Sentry Bots</option>
                    <option value="shield">Shield Orbs</option>
                </select>
            </div>
        </div>

        <!-- 4. Gameplay Effects -->
        <div class="custom-section">
            <h3>4. Weapon FX</h3>
            <div class="option-row">
                <span class="option-label">Projectile Color</span>
                <div class="color-swatch-group" id="swatch-weapon">
                    <!-- Generated via JS -->
                </div>
            </div>
        </div>

        <div class="action-btns">
            <button class="start-btn" onclick="saveAndStart()">DEPLOY UNIT</button>
        </div>
    </div>
  </div>
</div>

<!-- HUD -->
<div id="game-ui">
  <div class="hud-top">
    <div class="player-hud">
      <div class="p1-label" id="hud-p1-name">CYAN WARRIOR</div>
      <div class="hp-bar-bg"><div id="p1-hp" class="hp-bar-fill fill-p1"></div></div>
    </div>
    
    <button id="cam-toggle-btn" onclick="toggleCameraMode()">CAM: FOLLOW</button>
    
    <div class="player-hud" id="p2-hud-container" style="display:none; align-items:flex-end;">
      <div class="p2-label">CRIMSON WARRIOR</div>
      <div class="hp-bar-bg"><div id="p2-hp" class="hp-bar-fill fill-p2"></div></div>
    </div>
  </div>
  
  <div id="boss-hud-container">
    <div class="boss-name">CRIMSON NEBULA TITAN</div>
    <div class="hp-bar-bg" style="height:15px; transform:skewX(0);">
      <div id="boss-hp" class="hp-bar-fill fill-boss" style="width:100%;"></div>
    </div>
  </div>

  <div id="level-ind">SECTOR: NEBULA</div>

  <div id="radar-box">
    <canvas id="radar-canvas" width="200" height="200"></canvas>
  </div>

  <div id="producer-credit">Produced by Shivam Singh Patel</div>
</div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// --- SETUP ---
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.015);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 300);
camera.position.set(0, 5, 25);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.toneMapping = THREE.ReinhardToneMapping;
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// --- POST PROCESSING ---
const renderScene = new RenderPass(scene, camera);
const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
bloomPass.threshold = 0;
bloomPass.strength = 2.0; 
bloomPass.radius = 0.5;

const composer = new EffectComposer(renderer);
composer.addPass(renderScene);
composer.addPass(bloomPass);

// --- GAME STATE ---
const GAME = { active: false, mode: 1, levelIdx: 0, score: 0, bossSpawned: false, camMode: 'follow', state: 'menu' };
// 'state': 'menu', 'customize', 'playing'

const PLAYERS = [];
const BULLETS = [];
const ENEMIES = [];
const PARTICLES = [];
const LEVEL_OBJECTS = [];
let boss = null;

// --- FREE CAMERA VARIABLES ---
const freeCam = {
  theta: 0, phi: Math.PI / 3, radius: 50, target: new THREE.Vector3(0,0,0),
  isDragging: false, previousMouse: { x: 0, y: 0 }
};

// --- CUSTOMIZATION DATA ---
const CUSTOM_COLORS = {
    armor: [0x222222, 0x00ffff, 0xff00ff, 0xffff00, 0x00ff00, 0xff4400],
    neon: [0x00ffff, 0xff0000, 0xff00ff, 0xffff00, 0x00ff00, 0xffffff],
    weapon: [0x00ffff, 0xff0000, 0xffaa00, 0x00ff00, 0xffffff]
};

let playerCustomData = {
    armorColor: 0x222222,
    neonColor: 0x00ffff,
    material: 'metal',
    bulk: 1.0,
    anim: 'Idle',
    crown: 'none',
    jetpack: 'none',
    drones: 'none',
    weaponColor: 0x00ffff
};

// Preview Variables
let previewRobot = null;
let previewMixer = null;
let previewActions = {};
let previewControls = null;
let customDronesGroup = null; // Used for both preview and game player

// --- ASSETS ---
const MODEL_URL = "https://quantum-clash.vercel.app/assets/models/RobotExpressive.glb";
let baseRobotModel;

const loader = new GLTFLoader();
loader.load(MODEL_URL, (gltf) => {
  baseRobotModel = gltf.scene;
  baseRobotModel.traverse(c => {
    if (c.isMesh) {
      c.castShadow = true;
      c.receiveShadow = true;
    }
  });
  
  // Enable customize button once loaded
  document.getElementById('btn-customize').disabled = false;
  document.getElementById('btn-customize').innerText = "CUSTOMIZE";
  
  // Setup Preview Mixer immediately
  previewMixer = new THREE.AnimationMixer(baseRobotModel);
  gltf.animations.forEach(clip => {
      previewActions[clip.name] = previewMixer.clipAction(clip);
  });
  
}, undefined, (err) => {
    console.error("Model failed to load");
});

// --- AUDIO ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const Sound = {
  play: (freq, type, duration, vol=0.1) => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + duration);
  },
  shoot: () => Sound.play(800, 'sawtooth', 0.1, 0.05),
  enemyShoot: () => Sound.play(300, 'square', 0.3, 0.1),
  hit: () => Sound.play(150, 'sawtooth', 0.1),
  explosion: () => {
    Sound.play(50, 'sawtooth', 0.5, 0.2);
    Sound.play(30, 'square', 0.6, 0.2);
  },
  bossSpawn: () => {
    Sound.play(100, 'sawtooth', 2.0, 0.3);
    setTimeout(()=>Sound.play(80, 'square', 2.0, 0.3), 200);
  }
};

// --- BACKGROUND ASSETS ---
const starGeo = new THREE.BufferGeometry();
const starCount = 3000;
const starPos = [];
for(let i=0; i<starCount*3; i++) starPos.push((Math.random()-0.5)*200, (Math.random()-0.5)*100, (Math.random()-0.5)*200);
starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color:0xffffff, size:0.2, transparent:true, opacity:0.8}));
scene.add(stars);

const coreGeo = new THREE.IcosahedronGeometry(3, 1);
const coreMat = new THREE.MeshStandardMaterial({ color: 0x220044, emissive: 0xff00ff, emissiveIntensity: 2, wireframe: true });
const menuCore = new THREE.Mesh(coreGeo, coreMat);
scene.add(menuCore);

// --- CUSTOMIZATION UI SETUP ---

function setupColorSwatches(id, type) {
    const container = document.getElementById(id);
    CUSTOM_COLORS[type].forEach(color => {
        const div = document.createElement('div');
        div.className = 'color-swatch';
        div.style.backgroundColor = '#' + new THREE.Color(color).getHexString();
        div.onclick = () => {
            // Active state visual
            Array.from(container.children).forEach(c => c.classList.remove('active'));
            div.classList.add('active');
            
            // Update data
            playerCustomData[type] = color;
            updatePreview();
        };
        if(type === 'armor' && color === 0x222222) div.classList.add('active'); // Default
        if(type === 'neon' && color === 0x00ffff) div.classList.add('active'); // Default
        if(type === 'weapon' && color === 0x00ffff) div.classList.add('active'); // Default
        container.appendChild(div);
    });
}

setupColorSwatches('swatch-armor', 'armor');
setupColorSwatches('swatch-neon', 'neon');
setupColorSwatches('swatch-weapon', 'weapon');

window.openCustomize = () => {
    GAME.state = 'customize';
    document.getElementById('menu-screen').style.display = 'none';
    document.getElementById('custom-screen').style.display = 'flex';
    
    // Setup Preview Scene
    initPreviewRobot();
};

window.closeCustomize = () => {
    GAME.state = 'menu';
    document.getElementById('custom-screen').style.display = 'none';
    document.getElementById('menu-screen').style.display = 'flex';
    
    // Cleanup Preview
    if(previewRobot) {
        scene.remove(previewRobot);
        previewRobot = null;
    }
};

// --- PREVIEW ROBOT LOGIC ---

function initPreviewRobot() {
    if(!baseRobotModel) return;
    
    // Create a clone specifically for preview
    previewRobot = baseRobotModel.clone();
    previewRobot.position.set(0, 0, 0);
    
    // Remove from whereever it might have been
    scene.add(previewRobot);

    // Setup orbit controls just for preview
    // (We reuse the main renderer/scene, but move camera)
    camera.position.set(3, 2, 5);
    camera.lookAt(0, 1, 0);
    
    previewControls = new OrbitControls(camera, renderer.domElement);
    previewControls.enableDamping = true;
    previewControls.target.set(0, 1, 0);

    updatePreview();
}

function updatePreview() {
    if(!previewRobot) return;

    // 1. Apply Material & Color
    const isHolo = playerCustomData.material === 'holographic';
    const isMatte = playerCustomData.material === 'matte';
    
    previewRobot.traverse(c => {
        if(c.isMesh) {
            c.material = c.material.clone(); // Ensure unique material
            
            c.material.color.setHex(playerCustomData.armorColor);
            c.material.emissive.setHex(playerCustomData.neonColor);
            c.material.emissiveIntensity = isHolo ? 0.2 : 0.8;
            c.material.roughness = isMatte ? 0.9 : (isHolo ? 0.1 : 0.2);
            c.material.metalness = isMatte ? 0.1 : 0.9;
            c.material.wireframe = isHolo;
            
            // Add Decal (Stripe on chest)
            if(c.name === "RobotExpressive_Head" || c.name.includes("body")) {
               // Simple procedural logic: if it's the main body, we might add a stripe
               // For simplicity in this model, we just apply the color to all parts
            }
        }
    });

    // 2. Apply Bulk
    previewRobot.scale.setScalar(playerCustomData.bulk);

    // 3. Apply Accessories (Remove old, add new)
    // Helper to remove by userData type
    const removeOldParts = (type) => {
        const toRemove = [];
        previewRobot.traverse(c => {
            if(c.userData.type === type) toRemove.push(c);
        });
        toRemove.forEach(c => {
            if(c.parent) c.parent.remove(c);
        });
    };

    // --- CROWNS ---
    removeOldParts('crown');
    if(playerCustomData.crown !== 'none') {
        const head = findBone(previewRobot, "Head");
        if(head) {
            const crownGroup = new THREE.Group();
            crownGroup.userData.type = 'crown';
            
            let geo, mat = new THREE.MeshStandardMaterial({color:0xff0000, emissive:0xff0000, emissiveIntensity:2});
            
            if(playerCustomData.crown === 'horns') {
                geo = new THREE.ConeGeometry(0.1, 1, 4);
                const h1 = new THREE.Mesh(geo, mat); h1.position.set(0.3, 0.8, 0); h1.rotation.z = -0.3;
                const h2 = new THREE.Mesh(geo, mat); h2.position.set(-0.3, 0.8, 0); h2.rotation.z = 0.3;
                crownGroup.add(h1, h2);
            } else if (playerCustomData.crown === 'halo') {
                geo = new THREE.TorusGeometry(0.4, 0.02, 8, 20);
                const halo = new THREE.Mesh(geo, mat); halo.position.set(0, 0.5, 0); halo.rotation.x = Math.PI/2;
                crownGroup.add(halo);
            } else if (playerCustomData.crown === 'antenna') {
                geo = new THREE.CylinderGeometry(0.02, 0.02, 1);
                const ant = new THREE.Mesh(geo, mat); ant.position.set(0, 0.5, 0);
                const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.1), mat); bulb.position.set(0, 1, 0);
                crownGroup.add(ant, bulb);
            }
            
            // Attach to head bone approximate position (top of head mesh)
            // Since RobotExpressive bones are deep, we attach to the mesh object 'RobotExpressive_Head' if possible or top group
            const headMesh = previewRobot.getObjectByName("RobotExpressive_Head");
            if(headMesh) {
                crownGroup.position.set(0, 0.5, 0); 
                headMesh.add(crownGroup);
            }
        }
    }

    // --- JETPACKS ---
    removeOldParts('jetpack');
    if(playerCustomData.jetpack !== 'none') {
        const body = previewRobot.getObjectByName("RobotExpressive_Body"); // Approximation
        if(body) {
            const packGroup = new THREE.Group();
            packGroup.userData.type = 'jetpack';
            
            let mat = new THREE.MeshStandardMaterial({color:0x555555, metalness:0.8});
            let glowMat = new THREE.MeshBasicMaterial({color:playerCustomData.neonColor});
            
            if(playerCustomData.jetpack === 'thrusters') {
                const b = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1, 0.5), mat);
                const l1 = new THREE.Mesh(new THREE.CircleGeometry(0.2), glowMat); l1.position.set(0, -0.5, 0.26); l1.rotation.x = Math.PI/2;
                const l2 = l1.clone(); l2.position.set(0, -0.5, -0.26); l2.rotation.x = -Math.PI/2;
                packGroup.add(b, l1, l2);
            } else if (playerCustomData.jetpack === 'wings') {
                const w = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.1, 0.5), mat);
                packGroup.add(w);
            }
            
            packGroup.position.set(0, 0.5, -0.6);
            body.add(packGroup);
        }
    }

    // --- DRONES ---
    removeOldParts('drone');
    if(playerCustomData.drones !== 'none') {
        customDronesGroup = new THREE.Group();
        customDronesGroup.userData.type = 'drone';
        customDronesGroup.userData.droneType = playerCustomData.drones;
        
        const dMat = new THREE.MeshStandardMaterial({color:0x888888, emissive:playerCustomData.neonColor, emissiveIntensity:1});
        const geo = playerCustomData.drones === 'sentry' ? new THREE.BoxGeometry(0.2, 0.2, 0.4) : new THREE.SphereGeometry(0.15);
        
        const d1 = new THREE.Mesh(geo, dMat); d1.position.set(1.2, 1.5, 0.5);
        const d2 = new THREE.Mesh(geo, dMat); d2.position.set(-1.2, 1.5, 0.5);
        
        customDronesGroup.add(d1, d2);
        previewRobot.add(customDronesGroup);
    }

    // 4. Animation
    if(previewActions[playerCustomData.anim]) {
        // Fade out all others
        Object.values(previewActions).forEach(a => a.fadeOut(0.2));
        const current = previewActions[playerCustomData.anim];
        current.reset();
        current.fadeIn(0.2);
        current.play();
    }
}

function findBone(group, name) {
    let result = null;
    group.traverse(obj => {
        if(obj.isBone && obj.name === name) result = obj;
    });
    return result;
}

window.updatePreview = updatePreview; // Expose to HTML

// --- PLAYER CLASS (UPDATED FOR CUSTOMIZATION) ---

class Player {
  constructor(id, color, startPos, isCustom = false) {
    this.id = id;
    this.color = new THREE.Color(color);
    this.isCustom = isCustom; // If true, use playerCustomData
    this.hp = 100;
    this.dead = false;
    
    // Clone Model
    this.mesh = baseRobotModel ? baseRobotModel.clone() : new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:color}));
    
    // Apply Customization if P1
    if(isCustom) {
        this.applyGameplayCustomization();
        this.mixer = new THREE.AnimationMixer(this.mesh);
        baseRobotModel.parent?.animations.forEach(clip => { // Inherit animations logic
            // We actually need to find animations from the original gltf.
            // Since 'baseRobotModel' is a clone, animations are lost on the clone.
            // We need to access the global gltf animations. 
            // Simplified: We will just loop anims from baseRobotModel if available or stored globally.
        });
        
        // Re-fetching animations from the global resource
        // (In a robust setup, we'd pass the gltf object. Here we rely on `previewActions` keys or raw gltf ref if we had it stored globally)
        // Since we used `loader` locally, let's use a workaround: create a mixer and try to find clips from the original model's userData if we saved them.
        // For this snippet, P2 gets no anim mixing, P1 gets static application of custom data.
    } else {
        this.mesh.scale.set(1.5, 1.5, 1.5); // Standard P2 size
    }
    
    this.mesh.position.copy(startPos);
    scene.add(this.mesh);
    
    // Light
    this.light = new THREE.PointLight(this.isCustom ? playerCustomData.neonColor : this.color, 2, 15);
    this.mesh.add(this.light);
    
    // Custom Parts Containers (for updates)
    this.drones = null;
    this.dronesAngle = 0;
  }

  applyGameplayCustomization() {
      // 1. Scale (Bulk)
      this.mesh.scale.setScalar(playerCustomData.bulk);
      
      // 2. Materials
      const isHolo = playerCustomData.material === 'holographic';
      const isMatte = playerCustomData.material === 'matte';
      
      this.mesh.traverse(c => {
          if(c.isMesh) {
              c.material = c.material.clone();
              c.material.color.setHex(playerCustomData.armorColor);
              c.material.emissive.setHex(playerCustomData.neonColor);
              c.material.emissiveIntensity = isHolo ? 0.2 : 0.8;
              c.material.roughness = isMatte ? 0.9 : (isHolo ? 0.1 : 0.2);
              c.material.metalness = isMatte ? 0.1 : 0.9;
              c.material.wireframe = isHolo;
          }
      });

      // 3. Accessories (Re-implementation for Gameplay Player)
      // Note: We repeat logic from updatePreview but on the actual player mesh
      // Ideally this is a shared function, but for clarity, I put it here.
      
      // Add Jetpack
      if(playerCustomData.jetpack !== 'none') {
           const body = this.mesh.getObjectByName("RobotExpressive_Body");
           if(body) {
               const packGroup = new THREE.Group();
               let mat = new THREE.MeshStandardMaterial({color:0x555555, metalness:0.8});
               let glowMat = new THREE.MeshBasicMaterial({color:playerCustomData.neonColor});
               
               const b = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1, 0.5), mat);
               const l1 = new THREE.Mesh(new THREE.CircleGeometry(0.2), glowMat); l1.position.set(0, -0.5, 0.26); l1.rotation.x = Math.PI/2;
               const l2 = l1.clone(); l2.position.set(0, -0.5, -0.26); l2.rotation.x = -Math.PI/2;
               packGroup.add(b, l1, l2);
               packGroup.position.set(0, 0.5, -0.6);
               body.add(packGroup);
           }
      }
      
      // Add Crown
      if(playerCustomData.crown !== 'none') {
         const headMesh = this.mesh.getObjectByName("RobotExpressive_Head");
         if(headMesh) {
             const crownGroup = new THREE.Group();
             let mat = new THREE.MeshStandardMaterial({color:0xff0000, emissive:0xff0000, emissiveIntensity:2});
             if(playerCustomData.crown === 'horns') {
                 const geo = new THREE.ConeGeometry(0.1, 1, 4);
                 const h1 = new THREE.Mesh(geo, mat); h1.position.set(0.3, 0.8, 0); h1.rotation.z = -0.3;
                 const h2 = new THREE.Mesh(geo, mat); h2.position.set(-0.3, 0.8, 0); h2.rotation.z = 0.3;
                 crownGroup.add(h1, h2);
             }
             crownGroup.position.set(0, 0.5, 0);
             headMesh.add(crownGroup);
         }
      }
      
      // Add Drones
      if(playerCustomData.drones !== 'none') {
          this.drones = new THREE.Group();
          const dMat = new THREE.MeshStandardMaterial({color:0x888888, emissive:playerCustomData.neonColor, emissiveIntensity:1});
          const geo = playerCustomData.drones === 'sentry' ? new THREE.BoxGeometry(0.2, 0.2, 0.4) : new THREE.SphereGeometry(0.15);
          const d1 = new THREE.Mesh(geo, dMat); d1.position.set(1.2, 1.5, 0.5);
          const d2 = new THREE.Mesh(geo, dMat); d2.position.set(-1.2, 1.5, 0.5);
          this.drones.add(d1, d2);
          this.mesh.add(this.drones);
      }
      
      // 4. Update HUD Color
      const neonHex = '#' + new THREE.Color(playerCustomData.neonColor).getHexString();
      const armorHex = '#' + new THREE.Color(playerCustomData.armorColor).getHexString();
      
      const p1Fill = document.getElementById('p1-hp');
      p1Fill.style.background = `linear-gradient(90deg, ${neonHex}, ${armorHex})`;
      p1Fill.style.boxShadow = `0 0 15px ${neonHex}`;
      
      document.getElementById('hud-p1-name').style.color = neonHex;
      document.getElementById('hud-p1-name').style.textShadow = `0 0 10px ${neonHex}`;
  }

  update(dt, input) {
    if(this.dead) return;
    
    const speed = 20 * dt;
    let moving = false;
    
    if(input.up) { this.mesh.position.z -= speed; moving = true; }
    if(input.down) { this.mesh.position.z += speed; moving = true; }
    if(input.left) { this.mesh.position.x -= speed; moving = true; this.mesh.rotation.y = THREE.MathUtils.lerp(this.mesh.rotation.y, Math.PI/2, 0.2); }
    if(input.right) { this.mesh.position.x += speed; moving = true; this.mesh.rotation.y = THREE.MathUtils.lerp(this.mesh.rotation.y, -Math.PI/2, 0.2); }

    // Bobbing animation
    if(moving) {
        const baseBob = Math.abs(Math.sin(Date.now() * 0.008)) * 0.5;
        this.mesh.position.y = baseBob;
        
        // Emit Particles if customized
        if(this.isCustom) {
            if(Math.random() > 0.5) {
                spawnParticle(this.mesh.position, playerCustomData.weaponColor, 0.1);
            }
        }
    } else {
      this.mesh.rotation.y = THREE.MathUtils.lerp(this.mesh.rotation.y, 0, 0.1);
      this.mesh.position.y = 0;
    }
    
    // Animate Drones
    if(this.drones) {
        this.dronesAngle += dt * 2;
        this.drones.children.forEach((d, i) => {
            const offset = i === 0 ? 1 : -1;
            d.position.y = 1.5 + Math.sin(this.dronesAngle + i)*0.2;
            d.position.x = (1.2 * offset) + Math.cos(this.dronesAngle)*0.2;
        });
    }
  }

  takeDamage(amt) {
    this.hp -= amt;
    Sound.hit();
    // Flash white
    this.mesh.traverse(c => { if(c.isMesh) c.material.emissive.setHex(0xffffff); });
    setTimeout(() => { 
      if(this.mesh) {
          const flashColor = this.isCustom ? playerCustomData.neonColor : this.color;
          this.mesh.traverse(c => { if(c.isMesh) c.material.emissive.setHex(flashColor); });
      }
    }, 100);
    updateHUD();

    if(this.hp <= 0) this.die();
  }

  die() {
    this.dead = true;
    createExplosion(this.mesh.position, this.isCustom ? playerCustomData.neonColor : this.color, 30);
    scene.remove(this.mesh);
  }
}

// --- ENEMY & BOSS (Unchanged for brevity, kept logic same) ---

class Enemy {
  constructor() {
    this.hp = 30;
    const geo = new THREE.ConeGeometry(1, 2, 4);
    const mat = new THREE.MeshStandardMaterial({ color: 0x220000, emissive: 0xff0000, emissiveIntensity: 1, roughness: 0.4 });
    this.mesh = new THREE.Mesh(geo, mat);
    const angle = Math.random() * Math.PI * 2; const r = 40;
    this.mesh.position.set(Math.cos(angle)*r, 1, Math.sin(angle)*r);
    scene.add(this.mesh);
    const light = new THREE.PointLight(0xff0000, 1, 10);
    this.mesh.add(light);
  }
  update(dt) {
    let target = null; let minDist = 999;
    PLAYERS.forEach(p => {
        if(!p.dead) { const d = p.mesh.position.distanceTo(this.mesh.position); if(d < minDist) { minDist = d; target = p; } }
    });
    if(target) {
        const dir = new THREE.Vector3().subVectors(target.mesh.position, this.mesh.position).normalize();
        this.mesh.position.add(dir.multiplyScalar(5 * dt));
        this.mesh.lookAt(target.mesh.position);
    }
  }
}

class CrimsonNebulaTitan {
    constructor() {
        this.hp = 1000; this.maxHp = 1000; this.dead = false;
        this.mesh = new THREE.Group();
        const darkMetalMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.7, metalness: 0.8 });
        const neonMat = new THREE.MeshStandardMaterial({ color: 0x550000, emissive: 0xff0000, emissiveIntensity: 2 });
        
        // Simple Boss Construction (Kept same as before)
        const torso = new THREE.Mesh(new THREE.BoxGeometry(8, 6, 4), darkMetalMat); torso.position.y = 8; this.mesh.add(torso);
        this.core = new THREE.Mesh(new THREE.SphereGeometry(1.5, 16, 16), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
        this.core.position.set(0, 8, 2.5); this.mesh.add(this.core);
        const cage = new THREE.Mesh(new THREE.TorusGeometry(2, 0.2, 8, 6), neonMat); cage.position.set(0, 8, 2.2); this.mesh.add(cage); this.coreCage = cage;
        
        const headGroup = new THREE.Group(); headGroup.position.set(0, 12.5, 0);
        const head = new THREE.Mesh(new THREE.BoxGeometry(3, 2, 3), darkMetalMat); head.position.z = 1; headGroup.add(head);
        const eyeGeo = new THREE.BoxGeometry(0.8, 0.4, 0.2);
        headGroup.add(new THREE.Mesh(eyeGeo, neonMat).clone().set(-0.8, 0.2, 2.6));
        headGroup.add(new THREE.Mesh(eyeGeo, neonMat).clone().set(0.8, 0.2, 2.6));
        this.mesh.add(headGroup); this.head = headGroup;

        const shoulderGeo = new THREE.BoxGeometry(3, 2, 3);
        this.mesh.add(new THREE.Mesh(shoulderGeo, darkMetalMat).clone().set(-6, 9, 0));
        this.mesh.add(new THREE.Mesh(shoulderGeo, darkMetalMat).clone().set(6, 9, 0));
        
        const legGeo = new THREE.BoxGeometry(2, 6, 2);
        this.mesh.add(new THREE.Mesh(legGeo, darkMetalMat).clone().set(-2, 3, 0));
        this.mesh.add(new THREE.Mesh(legGeo, darkMetalMat).clone().set(2, 3, 0));
        
        this.mesh.position.set(0, 0, -40); scene.add(this.mesh);
        this.state = 'enter'; this.attackTimer = 0;
    }
    update(dt, players) {
        if(this.dead) return;
        const time = Date.now() * 0.001;
        const hpPercent = this.hp / this.maxHp;
        const pulseSpeed = 2 + (1 - hpPercent) * 5;
        this.core.material.color.setHSL(0, 1, 0.5 + Math.sin(time * pulseSpeed) * 0.5);
        this.coreCage.rotation.z += dt;
        
        if(this.state === 'enter') {
            this.mesh.position.z += 5 * dt;
            if(this.mesh.position.z >= -25) { this.state = 'idle'; showNotification("WARNING: TITAN DETECTED"); }
        } else {
            let target = null; let minDist = 999;
            players.forEach(p => { if(!p.dead) { const d = p.mesh.position.distanceTo(this.mesh.position); if(d < minDist) { minDist = d; target = p; } }});
            if(target) {
                const lookTarget = new THREE.Vector3(target.mesh.position.x, this.mesh.position.y, target.mesh.position.z);
                this.head.lookAt(lookTarget);
                if(minDist > 15) {
                    const dir = new THREE.Vector3().subVectors(target.mesh.position, this.mesh.position).normalize();
                    this.mesh.position.add(dir.multiplyScalar(3 * dt));
                    this.mesh.rotation.y = Math.atan2(dir.x, dir.z);
                    this.mesh.position.y = Math.abs(Math.sin(time * 5)) * 0.2;
                } else {
                    this.mesh.position.y = 0; this.state = 'attack';
                }
            }
            this.attackTimer += dt;
            if(this.attackTimer > 2.0) { this.attack(); this.attackTimer = 0; }
        }
    }
    attack() {
        Sound.enemyShoot();
        const positions = [new THREE.Vector3(-6, 7, 2), new THREE.Vector3(6, 7, 2)];
        let targetPos = new THREE.Vector3(0,0,0); PLAYERS.forEach(p => { if(!p.dead) targetPos = p.mesh.position; });
        positions.forEach(pos => {
            const worldPos = pos.clone().applyMatrix4(this.mesh.matrixWorld);
            const b = new THREE.Mesh(new THREE.SphereGeometry(0.8), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            b.position.copy(worldPos); scene.add(b);
            const dir = new THREE.Vector3().subVectors(targetPos, worldPos).normalize();
            dir.x += (Math.random()-0.5)*0.2; dir.z += (Math.random()-0.5)*0.2;
            BULLETS.push({ mesh: b, vel: dir.multiplyScalar(0.8), color: 0xff0000, owner: 'boss', damage: 20 });
        });
    }
    takeDamage(amt) {
        this.hp -= amt; Sound.hit();
        this.core.material.color.setHex(0xffffff);
        setTimeout(() => { if(!this.dead) this.core.material.color.setHex(0xff0000); }, 50);
        updateHUD();
        if(this.hp <= 0) this.die();
    }
    die() {
        this.dead = true; Sound.explosion(); createExplosion(this.mesh.position, 0xff0000, 100);
        setTimeout(() => { scene.remove(this.mesh); }, 100);
        document.getElementById('boss-hud-container').style.display = 'none';
        showNotification("TITAN DESTROYED"); GAME.score += 5000; GAME.bossSpawned = false;
    }
}

// --- LEVELS ---
function clearLevel() { LEVEL_OBJECTS.forEach(o => scene.remove(o)); LEVEL_OBJECTS.length = 0; }
function createNebulaLevel() {
  scene.fog.color.setHex(0x110022); scene.background = new THREE.Color(0x050010);
  const grid = new THREE.GridHelper(200, 100, 0xaa00aa, 0x110011); scene.add(grid); LEVEL_OBJECTS.push(grid);
}
function createCityLevel() {
  scene.fog.color.setHex(0x001133); scene.background = new THREE.Color(0x000510);
  const floorMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.0, metalness: 0.8 });
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(300,300), floorMat); floor.rotation.x = -Math.PI/2; scene.add(floor); LEVEL_OBJECTS.push(floor);
  const bGeo = new THREE.BoxGeometry(10, 40, 10); const bMat = new THREE.MeshStandardMaterial({ color: 0x050510, roughness: 0.1, metalness: 0.8 });
  for(let i=0; i<50; i++) {
    const b = new THREE.Mesh(bGeo, bMat); b.position.set((Math.random()-0.5)*200, 20, (Math.random()-0.5)*200);
    if(b.position.length() < 30) b.position.setLength(40); scene.add(b); LEVEL_OBJECTS.push(b);
  }
}
function createAsteroidLevel() {
  scene.fog.color.setHex(0x331100); scene.background = new THREE.Color(0x100500);
  const grid = new THREE.GridHelper(200, 50, 0xff4400, 0x220000); scene.add(grid); LEVEL_OBJECTS.push(grid);
  const rockGeo = new THREE.DodecahedronGeometry(4); const rockMat = new THREE.MeshStandardMaterial({ color: 0x552200, flatShading: true });
  for(let i=0; i<30; i++) {
    const r = new THREE.Mesh(rockGeo, rockMat);
    const pos = new THREE.Vector3((Math.random()-0.5)*150, Math.random()*2, (Math.random()-0.5)*150);
    if(pos.length() < 20) pos.setLength(30); r.position.copy(pos); scene.add(r); LEVEL_OBJECTS.push(r);
  }
}

// --- PARTICLES ---
function spawnParticle(pos, color, scale=0.5) {
  const geo = new THREE.TetrahedronGeometry(scale);
  const mat = new THREE.MeshBasicMaterial({ color: color });
  const p = new THREE.Mesh(geo, mat);
  p.position.copy(pos);
  p.userData = { vel: new THREE.Vector3((Math.random()-0.5)*0.5, Math.random()*0.5, (Math.random()-0.5)*0.5), life: 1.0 };
  scene.add(p); PARTICLES.push(p);
}
function createExplosion(pos, color, count) {
  Sound.explosion();
  for(let i=0; i<count; i++) spawnParticle(pos, color, Math.random()*0.5 + 0.2);
}

// --- CORE LOGIC ---

const keys = {};
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

const getInpP1 = () => ({ up: keys['KeyW'], down: keys['KeyS'], left: keys['KeyA'], right: keys['KeyD'], fire: keys['Space'] });
const getInpP2 = () => ({ up: keys['ArrowUp'], down: keys['ArrowDown'], left: keys['ArrowLeft'], right: keys['ArrowRight'], fire: keys['Enter'] });

let lastShot = [0, 0];

function update(dt) {
  if(!GAME.active) return;

  // Player Logic
  if(!PLAYERS[0].dead) {
    PLAYERS[0].update(dt, getInpP1());
    if(getInpP1().fire && Date.now() > lastShot[0]) { shoot(PLAYERS[0]); lastShot[0] = Date.now() + 150; }
  }
  if(PLAYERS[1] && !PLAYERS[1].dead) {
    PLAYERS[1].update(dt, getInpP2());
    if(getInpP2().fire && Date.now() > lastShot[1]) { shoot(PLAYERS[1]); lastShot[1] = Date.now() + 150; }
  }

  // Bullet Logic
  for(let i=BULLETS.length-1; i>=0; i--) {
    const b = BULLETS[i];
    b.mesh.position.add(b.vel);
    if(Math.random() > 0.5) spawnParticle(b.mesh.position, b.color, 0.1);
    if(b.mesh.position.length() > 150) { scene.remove(b.mesh); BULLETS.splice(i,1); continue; }
    
    if(b.owner !== 'boss') {
        if(boss && !boss.dead && b.mesh.position.distanceTo(boss.mesh.position) < 8) {
            createExplosion(b.mesh.position, 0xffaa00, 3); boss.takeDamage(10); scene.remove(b.mesh); BULLETS.splice(i,1); continue;
        }
        for(let j=ENEMIES.length-1; j>=0; j--) {
            if(b.mesh.position.distanceTo(ENEMIES[j].mesh.position) < 2) {
                createExplosion(ENEMIES[j].mesh.position, 0xffaa00, 5);
                scene.remove(ENEMIES[j].mesh); ENEMIES.splice(j,1);
                GAME.score += 100; scene.remove(b.mesh); BULLETS.splice(i,1); break;
            }
        }
    } else {
        PLAYERS.forEach(p => {
            if(!p.dead && b.mesh.position.distanceTo(p.mesh.position) < 2) {
                p.takeDamage(b.damage || 10); createExplosion(b.mesh.position, 0xff0000, 5);
                scene.remove(b.mesh); const idx = BULLETS.indexOf(b); if(idx > -1) BULLETS.splice(idx, 1);
            }
        });
    }
  }

  // Enemy Logic
  ENEMIES.forEach(e => e.update(dt));
  if(boss && !boss.dead) { if(Math.random() < 0.01 && ENEMIES.length < 3) ENEMIES.push(new Enemy()); }
  else { if(Math.random() < 0.02 && ENEMIES.length < 8) ENEMIES.push(new Enemy()); }

  if(GAME.score >= 500 && !GAME.bossSpawned && !boss) {
      GAME.bossSpawned = true; boss = new CrimsonNebulaTitan();
      document.getElementById('boss-hud-container').style.display = 'block'; Sound.bossSpawn();
  }
  if(boss) boss.update(dt, PLAYERS);

  // Particles
  for(let i=PARTICLES.length-1; i>=0; i--) {
    const p = PARTICLES[i]; p.position.add(p.userData.vel); p.userData.vel.y -= 0.02;
    p.userData.life -= 0.02; p.scale.setScalar(p.userData.life); p.rotation.x += 0.1;
    if(p.userData.life <= 0) { scene.remove(p); PARTICLES.splice(i,1); }
  }

  drawRadar(); updateHUD();
}

function shoot(player) {
  Sound.shoot();
  // Use custom color if P1, else default
  const pColor = (player.id === 0 && player.isCustom) ? playerCustomData.weaponColor : player.color;
  
  const bMesh = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({ color: pColor }));
  bMesh.position.copy(player.mesh.position); bMesh.position.y += 1.5;
  const dir = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), player.mesh.rotation.y);
  scene.add(bMesh);
  BULLETS.push({ mesh: bMesh, vel: dir.multiplyScalar(2), color: pColor, owner: player.id });
}

function updateHUD() {
  if(PLAYERS[0]) document.getElementById('p1-hp').style.width = PLAYERS[0].hp + '%';
  if(PLAYERS[1]) document.getElementById('p2-hp').style.width = PLAYERS[1].hp + '%';
  if(boss) { const pct = Math.max(0, (boss.hp / boss.maxHp) * 100); document.getElementById('boss-hp').style.width = pct + '%'; }
}

function drawRadar() {
  const cvs = document.getElementById('radar-canvas'); const ctx = cvs.getContext('2d');
  ctx.clearRect(0,0,200,200);
  ctx.strokeStyle = 'rgba(0,255,0,0.2)';
  ctx.beginPath(); ctx.arc(100,100,90,0,Math.PI*2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(100,0); ctx.lineTo(100,200); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,100); ctx.lineTo(200,100); ctx.stroke();
  const scale = 1.0; const cx = 100; const cz = 100;
  PLAYERS.forEach(p => {
    if(!p.dead) {
        ctx.fillStyle = p.id===0 ? '#0ff' : '#f00'; // Radar always cyan/red for visibility
        ctx.beginPath(); ctx.arc(cx + p.mesh.position.x*scale, cz + p.mesh.position.z*scale, 3, 0, Math.PI*2); ctx.fill();
    }
  });
  if(boss && !boss.dead) {
      ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.arc(cx + boss.mesh.position.x*scale, cz + boss.mesh.position.z*scale, 8, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#fff'; ctx.stroke();
  }
  ctx.fillStyle = 'rgba(255,0,0,0.5)';
  ENEMIES.forEach(e => { ctx.beginPath(); ctx.arc(cx + e.mesh.position.x*scale, cz + e.mesh.position.z*scale, 2, 0, Math.PI*2); ctx.fill(); });
}

function showNotification(text) {
    const el = document.getElementById('center-notify'); el.innerText = text;
    el.style.opacity = 1; el.style.transform = "scale(1.5)";
    setTimeout(() => { el.style.opacity = 0; el.style.transform = "scale(1)"; }, 2000);
}

// --- MENU / GAME START LOGIC ---

window.setLevel = (idx, el) => {
  GAME.levelIdx = idx;
  document.querySelectorAll('.level-opt').forEach(o => o.classList.remove('active'));
  el.classList.add('active');
};

window.saveAndStart = () => {
    // Start game with P1 using customization
    startGame(1);
};

window.startGame = (mode) => {
  GAME.mode = mode; GAME.active = true; GAME.score = 0; GAME.bossSpawned = false; boss = null;
  document.getElementById('menu-screen').style.display = 'none';
  document.getElementById('custom-screen').style.display = 'none'; // Ensure custom screen is hidden
  document.getElementById('game-ui').style.display = 'block';
  document.getElementById('boss-hud-container').style.display = 'none';
  
  if(audioCtx.state === 'suspended') audioCtx.resume();

  // Cleanup Preview Robot if exists
  if(previewRobot) { scene.remove(previewRobot); previewRobot = null; }

  clearLevel();
  if(GAME.levelIdx === 0) { createNebulaLevel(); document.getElementById('level-ind').innerText = "SECTOR: NEBULA"; }
  else if(GAME.levelIdx === 1) { createCityLevel(); document.getElementById('level-ind').innerText = "SECTOR: CYBER CITY"; }
  else { createAsteroidLevel(); document.getElementById('level-ind').innerText = "SECTOR: ASTEROID BELT"; }

  PLAYERS.forEach(p => scene.remove(p.mesh)); PLAYERS.length = 0;
  
  // P1 gets customization, P2 is standard
  PLAYERS.push(new Player(0, 0x00ffff, new THREE.Vector3(0,0,20), true));
  
  if(mode === 2) {
    PLAYERS.push(new Player(1, 0xff0000, new THREE.Vector3(5,0,20), false));
    document.getElementById('p2-hud-container').style.display = 'flex';
  } else {
    document.getElementById('p2-hud-container').style.display = 'none';
  }
  
  GAME.state = 'playing';
  showNotification("COMBAT STARTED");
};

// --- CAMERA CONTROLS ---
window.toggleCameraMode = () => {
    if(GAME.camMode === 'follow') {
        GAME.camMode = 'free'; document.getElementById('cam-toggle-btn').innerText = "CAM: FREE";
        document.getElementById('cam-toggle-btn').style.color = "#f0f"; showNotification("CAMERA MODE: FREE");
    } else {
        GAME.camMode = 'follow'; document.getElementById('cam-toggle-btn').innerText = "CAM: FOLLOW";
        document.getElementById('cam-toggle-btn').style.color = "#0ff"; showNotification("CAMERA MODE: LOCKED");
    }
};

document.addEventListener('mousedown', (e) => { if(GAME.state === 'playing' && GAME.camMode === 'free' && e.button === 2) { freeCam.isDragging = true; freeCam.previousMouse = { x: e.clientX, y: e.clientY }; } });
document.addEventListener('mouseup', () => { freeCam.isDragging = false; });
document.addEventListener('mousemove', (e) => {
    if(freeCam.isDragging) {
        const deltaX = e.clientX - freeCam.previousMouse.x; const deltaY = e.clientY - freeCam.previousMouse.y;
        freeCam.theta -= deltaX * 0.005; freeCam.phi -= deltaY * 0.005;
        freeCam.phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, freeCam.phi));
        freeCam.previousMouse = { x: e.clientX, y: e.clientY };
    }
});
document.addEventListener('wheel', (e) => { if(GAME.state === 'playing' && GAME.camMode === 'free') { freeCam.radius += e.deltaY * 0.05; freeCam.radius = Math.max(10, Math.min(100, freeCam.radius)); } });
document.addEventListener('contextmenu', event => event.preventDefault());

// --- RENDER LOOP ---
const clock = new THREE.Clock();
function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta(); const time = Date.now() * 0.001;

  update(dt);

  // Camera Logic
  if(GAME.state === 'menu') {
    camera.position.x = Math.sin(time * 0.1) * 20; camera.position.z = 20 + Math.cos(time * 0.1) * 10;
    camera.position.y = 5 + Math.sin(time * 0.2) * 2; camera.lookAt(0, 0, 0);
    menuCore.rotation.x = time * 0.5; menuCore.rotation.y = time * 0.3;
    const positions = stars.geometry.attributes.position.array;
    for(let i=1; i<positions.length; i+=3) { positions[i] -= 0.05; if(positions[i] < -50) positions[i] = 50; }
    stars.geometry.attributes.position.needsUpdate = true;
  } 
  else if (GAME.state === 'customize') {
      if(previewControls) {
          previewControls.update();
      }
      // Update animation mixer for preview
      if(previewMixer) previewMixer.update(dt);
  }
  else if (GAME.state === 'playing') {
    if (GAME.camMode === 'free') {
        camera.position.x = freeCam.radius * Math.sin(freeCam.phi) * Math.sin(freeCam.theta);
        camera.position.y = freeCam.radius * Math.cos(freeCam.phi);
        camera.position.z = freeCam.radius * Math.sin(freeCam.phi) * Math.cos(freeCam.theta);
        const target = (boss && !boss.dead) ? boss.mesh.position : new THREE.Vector3(0,0,0);
        camera.lookAt(target);
    } else {
        let targetPlayer = PLAYERS[0];
        if(targetPlayer.dead && PLAYERS[1]) targetPlayer = PLAYERS[1];
        if(targetPlayer) {
            const pPos = targetPlayer.mesh.position;
            const offset = new THREE.Vector3(0, 25, -25);
            const playerRotation = targetPlayer.mesh.rotation.y;
            offset.applyAxisAngle(new THREE.Vector3(0,1,0), playerRotation);
            const desiredPos = pPos.clone().add(offset);
            camera.position.lerp(desiredPos, 0.1);
            const lookAtOffset = new THREE.Vector3(0, 0, -10);
            lookAtOffset.applyAxisAngle(new THREE.Vector3(0,1,0), playerRotation);
            camera.lookAt(pPos.clone().add(lookAtOffset));
        }
    }
  }

  composer.render();
}

window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); });
animate();

</script>
</body>
</html>
