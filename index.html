<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>QuantumClash: Cyber Arena Ultimate</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

  body { margin:0; overflow:hidden; background:#000; font-family:'Orbitron', sans-serif; color:white; user-select:none; }
  
  /* --- UI LAYOUT --- */
  #game-ui { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:none; }
  
  /* HUD TOP */
  .hud-top { position: absolute; top:0; width:100%; height: 60px; display:flex; justify-content:space-between; padding:10px 20px; box-sizing:border-box; background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent); }
  
  .p1-stats { color:#0ff; text-shadow: 0 0 10px #0ff; }
  .p2-stats { color:#f00; text-shadow: 0 0 10px #f00; text-align:right; }
  
  .bar-container { width:200px; height:10px; background:#333; margin-top:5px; border:1px solid #555; }
  .bar-fill { height:100%; width:100%; transition:width 0.2s; }
  .hp-p1 { background:#0ff; box-shadow:0 0 10px #0ff; }
  .hp-p2 { background:#f00; box-shadow:0 0 10px #f00; }

  /* CENTER INFO */
  #center-msg { position:absolute; top:40%; width:100%; text-align:center; font-size:3rem; text-shadow:0 0 20px white; opacity:0; transition:opacity 0.5s; pointer-events:none;}
  
  /* RADAR / MINIMAP */
  #radar-container { position:absolute; bottom:20px; right:20px; width:150px; height:150px; background:rgba(0,20,0,0.8); border:2px solid #0f0; border-radius:50%; overflow:hidden; }
  #radar-canvas { width:100%; height:100%; }

  /* LEADERBOARD */
  #leaderboard { position:absolute; top:70px; right:20px; width:200px; background:rgba(0,0,0,0.7); border:1px solid #555; padding:10px; font-size:0.8rem; }
  .lb-row { display:flex; justify-content:space-between; margin-bottom:5px; border-bottom:1px solid #333; }

  /* MAIN MENU */
  #main-menu { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(5,5,10,0.95); z-index:100; display:flex; flex-direction:column; align-items:center; justify-content:center; pointer-events:auto; }
  
  h1 { font-size:4rem; color:#0ff; text-transform:uppercase; text-shadow: 0 0 30px #0ff; margin-bottom:10px; letter-spacing:5px; }
  
  .menu-btn {
    background:transparent; border:2px solid #0ff; color:#fff; padding:15px 40px; margin:10px; 
    font-family:inherit; font-size:1.5rem; cursor:pointer; transition:0.3s; width:300px; text-align:center;
  }
  .menu-btn:hover { background:#0ff; color:#000; box-shadow:0 0 30px #0ff; }
  .menu-btn.pvp { border-color:#f00; color:#f00; }
  .menu-btn.pvp:hover { background:#f00; color:#fff; box-shadow:0 0 30px #f00; }

  .controls-hint { margin-top:30px; color:#888; font-size:0.8rem; text-align:center; line-height:1.5; }

  /* LEVEL SELECT */
  #level-select { display:none; flex-direction:row; gap:20px; margin-top:20px; }
  .level-card { width:150px; height:100px; border:2px solid #333; display:flex; align-items:center; justify-content:center; cursor:pointer; transition:0.3s; }
  .level-card:hover, .level-card.active { border-color:#fff; background:rgba(255,255,255,0.1); }
</style>

<!-- Import Maps -->
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>
</head>
<body>

<!-- MAIN MENU -->
<div id="main-menu">
  <h1>Quantum Clash</h1>
  <div id="level-select">
    <div class="level-card active" onclick="selectLevel(0, this)">NEBULA</div>
    <div class="level-card" onclick="selectLevel(1, this)">CITY</div>
    <div class="level-card" onclick="selectLevel(2, this)">ASTEROID</div>
  </div>
  <button class="menu-btn" onclick="startGame(1)">1 PLAYER</button>
  <button class="menu-btn" onclick="startGame(2)">2 PLAYER CO-OP</button>
  <button class="menu-btn pvp" onclick="startGame(3)">2 PLAYER VS</button>
  <div class="controls-hint">
    P1: [W A S D] Move | [SPACE] Shoot<br>
    P2: [ARROWS] Move | [ENTER] Shoot
  </div>
</div>

<!-- IN-GAME HUD -->
<div id="game-ui">
  <div class="hud-top">
    <div class="p1-stats">
      <div>P1 CYAN</div>
      <div class="bar-container"><div id="p1-hp" class="bar-fill hp-p1"></div></div>
    </div>
    <div style="color:#fff; font-weight:bold;" id="score-display">SCORE: 0</div>
    <div class="p2-stats" id="p2-panel" style="display:none;">
      <div>P2 RED</div>
      <div class="bar-container"><div id="p2-hp" class="bar-fill hp-p2"></div></div>
    </div>
  </div>
  
  <div id="center-msg">WAVE 1 START</div>

  <div id="leaderboard">
    <div style="color:#aaa; border-bottom:1px solid #555; margin-bottom:5px;">LEADERBOARD</div>
    <div class="lb-row"><span>P1</span><span id="lb-score-1">0</span></div>
    <div class="lb-row"><span>P2</span><span id="lb-score-2">0</span></div>
  </div>

  <div id="radar-container">
    <canvas id="radar-canvas" width="150" height="150"></canvas>
  </div>
</div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

// --- GAME CONFIGURATION ---
const CONFIG = {
  arenaSize: 60,
  bulletSpeed: 1.5,
  enemySpawnRate: 2000
};

// --- STATE MANAGEMENT ---
const STATE = {
  mode: 1, // 1: Solo, 2: Co-op, 3: Versus
  level: 0,
  scoreP1: 0,
  scoreP2: 0,
  wave: 1,
  active: false
};

const LEVELS = [
  { name: "NEBULA", fogColor: 0x110022, gridColor: 0xaa00ff, bgColor: 0x000000 },
  { name: "CYBER CITY", fogColor: 0x001133, gridColor: 0x00ffff, bgColor: 0x050505 },
  { name: "ASTEROID", fogColor: 0x330000, gridColor: 0xff4400, bgColor: 0x100000 }
];

// --- THREE.JS SETUP ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 50, 40); // High angle view for arena
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// Lighting
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);
const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(20, 50, 20);
dirLight.castShadow = true;
scene.add(dirLight);

// --- AUDIO SYSTEM (Procedural) ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const Sound = {
  playTone: (freq, type, dur) => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + dur);
  },
  shoot: () => Sound.playTone(800, 'sawtooth', 0.15),
  explosion: () => Sound.playTone(100, 'square', 0.3),
  hit: () => Sound.playTone(200, 'triangle', 0.1)
};

// --- GAME ENTITIES ---
let players = [];
let enemies = [];
let bullets = [];
let particles = [];
let levelObjects = []; // Buildings, hazards, etc.

const loader = new GLTFLoader();
const MODEL_URL = "https://quantum-clash.vercel.app/assets/models/RobotExpressive.glb";
let baseModel;

// --- CLASSES ---

class Player {
  constructor(id, color, startPos) {
    this.id = id;
    this.hp = 100;
    this.dead = false;
    this.color = color;
    
    this.mesh = baseModel.clone();
    this.mesh.scale.set(1.5, 1.5, 1.5);
    this.mesh.traverse(c => {
      if(c.isMesh) {
        c.material = c.material.clone();
        c.material.color.setHex(color);
        c.material.emissive = new THREE.Color(color);
        c.material.emissiveIntensity = 0.5;
        c.castShadow = true;
      }
    });
    
    this.mesh.position.copy(startPos);
    scene.add(this.mesh);

    this.mixer = new THREE.AnimationMixer(this.mesh);
    const idleClip = THREE.AnimationClip.findByName(this.mesh.userData.animations || [], 'Idle'); // Fallback
    // Since we cloned, animations aren't copied directly to userData in older Three versions easily, 
    // assuming we use the global animations array logic
    this.actions = {};
    
    // Find animations from the base gltf logic later
    this.velocity = new THREE.Vector3();
  }

  update(dt, input) {
    if(this.dead) return;
    
    // Movement
    const speed = 20 * dt;
    let moving = false;
    
    if(input.up) { this.mesh.position.z -= speed; moving = true; }
    if(input.down) { this.mesh.position.z += speed; moving = true; }
    if(input.left) { this.mesh.position.x -= speed; moving = true; this.mesh.rotation.y = Math.PI/2; }
    if(input.right) { this.mesh.position.x += speed; moving = true; this.mesh.rotation.y = -Math.PI/2; }

    // Clamp
    this.mesh.position.x = Math.max(-CONFIG.arenaSize/2, Math.min(CONFIG.arenaSize/2, this.mesh.position.x));
    this.mesh.position.z = Math.max(-CONFIG.arenaSize/2, Math.min(CONFIG.arenaSize/2, this.mesh.position.z));

    // Animation Logic
    if(moving) {
      // Simple running animation simulation if clip not found
      this.mesh.position.y = Math.abs(Math.sin(Date.now()*0.01)) * 0.5;
    } else {
      this.mesh.position.y = 0;
    }
  }

  shoot() {
    if(this.dead) return;
    Sound.shoot();
    const b = new Bullet(this.mesh.position, this.color, true, this.id);
    bullets.push(b);
  }

  takeDamage(amount) {
    this.hp -= amount;
    Sound.hit();
    // Flash red
    this.mesh.traverse(c => { if(c.isMesh) c.material.emissive.setHex(0xffffff); });
    setTimeout(() => { 
       if(this.mesh) this.mesh.traverse(c => { if(c.isMesh) c.material.emissive.setHex(this.color); });
    }, 100);

    if(this.hp <= 0) {
      this.die();
    }
    updateHUD();
  }

  die() {
    this.dead = true;
    scene.remove(this.mesh);
    createExplosion(this.mesh.position, this.color, 20);
    checkWinCondition();
  }
}

class Enemy {
  constructor(type) {
    this.type = type; // 0: Drone, 1: Tank, 2: Boss
    this.hp = type === 1 ? 50 : (type === 2 ? 300 : 20);
    this.dead = false;
    
    const geo = type === 1 ? new THREE.BoxGeometry(2,2,2) : (type === 2 ? new THREE.IcosahedronGeometry(4) : new THREE.ConeGeometry(0.8, 2, 4));
    const color = type === 1 ? 0xff00ff : (type === 2 ? 0xffaa00 : 0xff0000);
    const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.8 });
    
    this.mesh = new THREE.Mesh(geo, mat);
    
    // Spawn at edge
    const angle = Math.random() * Math.PI * 2;
    const r = CONFIG.arenaSize/2 + 5;
    this.mesh.position.set(Math.cos(angle)*r, type===2?2:1, Math.sin(angle)*r);
    
    scene.add(this.mesh);
    this.lastShot = 0;
  }

  update(dt) {
    if(this.dead) return;

    // Target closest living player
    let target = null;
    let minDist = 999;
    players.forEach(p => {
      if(!p.dead) {
        const d = p.mesh.position.distanceTo(this.mesh.position);
        if(d < minDist) { minDist = d; target = p; }
      }
    });

    if(!target) return; // No players left

    const speed = this.type === 2 ? 0.05 : (this.type === 1 ? 0.1 : 0.3);
    
    // Move towards target
    const dir = new THREE.Vector3().subVectors(target.mesh.position, this.mesh.position).normalize();
    this.mesh.position.add(dir.multiplyScalar(speed));
    this.mesh.lookAt(target.mesh.position);

    // Shoot logic
    const now = Date.now();
    const fireRate = this.type === 2 ? 500 : (this.type === 1 ? 2000 : 1000);
    
    if(now - this.lastShot > fireRate && minDist < 40) {
      this.shoot(target.mesh.position);
      this.lastShot = now;
    }
  }

  shoot(targetPos) {
    const b = new Bullet(this.mesh.position, 0xff00ff, false, 0);
    bullets.push(b);
  }

  takeDamage(amount) {
    this.hp -= amount;
    this.mesh.scale.setScalar(1 + (10-this.hp)/50); // Flinch size
    setTimeout(() => this.mesh.scale.setScalar(this.type===2?4: (this.type===1?2:1)), 100);

    if(this.hp <= 0) {
      this.dead = true;
      scene.remove(this.mesh);
      createExplosion(this.mesh.position, 0xffaa00);
      if(this.type === 2) STATE.scoreP1 += 5000; else STATE.scoreP1 += 100;
      updateHUD();
    }
  }
}

class Bullet {
  constructor(pos, color, isPlayer, ownerId) {
    this.ownerId = ownerId;
    this.isPlayer = isPlayer;
    this.mesh = new THREE.Mesh(
      new THREE.SphereGeometry(0.4),
      new THREE.MeshBasicMaterial({ color: color })
    );
    this.mesh.position.copy(pos);
    this.mesh.position.y = 1.5;
    this.velocity = new THREE.Vector3(0,0, isPlayer ? -CONFIG.bulletSpeed : CONFIG.bulletSpeed); // Default Z, updated logic below
    scene.add(this.mesh);
    this.life = 2.0; // Seconds
  }
  
  // Override velocity immediately after creation based on rotation or direction
  setDirection(vec) { this.velocity.copy(vec).normalize().multiplyScalar(CONFIG.bulletSpeed); }
  
  update(dt) {
    this.mesh.position.add(this.velocity);
    this.life -= dt;
  }
}

// --- LEVEL GENERATION ---

function clearLevel() {
  levelObjects.forEach(o => scene.remove(o));
  levelObjects = [];
}

function generateLevel(index) {
  clearLevel();
  const conf = LEVELS[index];
  
  // Sky/Fog
  scene.background = new THREE.Color(conf.bgColor);
  scene.fog = new THREE.Fog(conf.fogColor, 10, 90);

  // Floor
  const grid = new THREE.GridHelper(CONFIG.arenaSize, 20, conf.gridColor, 0x111111);
  scene.add(grid);
  levelObjects.push(grid);
  
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(CONFIG.arenaSize, CONFIG.arenaSize),
    new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.1, metalness: 0.8 })
  );
  floor.rotation.x = -Math.PI/2;
  floor.receiveShadow = true;
  scene.add(floor);
  levelObjects.push(floor);

  // Specific Level Elements
  if(index === 0) { // Nebula: Floating Platforms
    for(let i=0; i<5; i++) {
      const p = new THREE.Mesh(new THREE.BoxGeometry(5,1,5), new THREE.MeshStandardMaterial({color:0x330033, wireframe:true}));
      p.position.set((Math.random()-0.5)*40, 2, (Math.random()-0.5)*40);
      scene.add(p);
      levelObjects.push(p);
    }
  } else if (index === 1) { // City: Buildings
    const geo = new THREE.BoxGeometry(4, 20, 4);
    const mat = new THREE.MeshStandardMaterial({color:0x001122});
    for(let i=0; i<15; i++) {
      const b = new THREE.Mesh(geo, mat);
      b.position.set((Math.random()-0.5)*50, 10, (Math.random()-0.5)*50);
      scene.add(b);
      levelObjects.push(b);
    }
  } else { // Asteroid: Rocks/Hazards
    const geo = new THREE.DodecahedronGeometry(3);
    const mat = new THREE.MeshStandardMaterial({color:0x442200});
    for(let i=0; i<10; i++) {
      const r = new THREE.Mesh(geo, mat);
      r.position.set((Math.random()-0.5)*50, 1, (Math.random()-0.5)*50);
      r.scale.set(1+Math.random(), 1+Math.random(), 1+Math.random());
      scene.add(r);
      levelObjects.push(r);
    }
  }
}

// --- PARTICLE SYSTEM ---
function createExplosion(pos, color, count=10) {
  Sound.explosion();
  for(let i=0; i<count; i++) {
    const geo = new THREE.TetrahedronGeometry(0.2);
    const mat = new THREE.MeshBasicMaterial({color:color});
    const p = new THREE.Mesh(geo, mat);
    p.position.copy(pos);
    p.userData = {
      vel: new THREE.Vector3((Math.random()-0.5), Math.random(), (Math.random()-0.5)).multiplyScalar(0.5),
      life: 1.0
    };
    scene.add(p);
    particles.push(p);
  }
}

// --- INPUT HANDLING ---
const keys = {};
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

const inputP1 = () => ({
  up: keys['KeyW'], down: keys['KeyS'], left: keys['KeyA'], right: keys['KeyD'], fire: keys['Space']
});
const inputP2 = () => ({
  up: keys['ArrowUp'], down: keys['ArrowDown'], left: keys['ArrowLeft'], right: keys['ArrowRight'], fire: keys['Enter']
});

// --- LOGIC ---

let shootCooldowns = [0, 0];

function updateGame(dt) {
  if(!STATE.active) return;

  // Player Inputs
  if(!players[0].dead) {
    players[0].update(dt, inputP1());
    if(inputP1().fire && Date.now() > shootCooldowns[0]) {
      players[0].shoot(); 
      shootCooldowns[0] = Date.now() + 200;
    }
  }
  
  if(players[1]) {
    if(!players[1].dead) {
      players[1].update(dt, inputP2());
      if(inputP2().fire && Date.now() > shootCooldowns[1]) {
        players[1].shoot();
        shootCooldowns[1] = Date.now() + 200;
      }
    }
  }

  // Bullet Logic
  for(let i=bullets.length-1; i>=0; i--) {
    const b = bullets[i];
    b.update(dt);
    
    // Direction override for players (shoot forward relative to model)
    if(b.isPlayer) {
       const owner = players.find(p => p.id === b.ownerId);
       if(owner && !owner.dead) {
         // Shoot in direction player is facing
         const forward = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), owner.mesh.rotation.y);
         b.setDirection(forward);
       }
    }

    // Bounds
    if(b.life <= 0 || Math.abs(b.mesh.position.x) > 50 || Math.abs(b.mesh.position.z) > 50) {
      scene.remove(b.mesh); bullets.splice(i,1); continue;
    }

    // Collisions
    if(b.isPlayer) {
      // Hit Enemy
      for(let j=enemies.length-1; j>=0; j--) {
        if(b.mesh.position.distanceTo(enemies[j].mesh.position) < 2) {
          enemies[j].takeDamage(10);
          createExplosion(b.mesh.position, 0xffff00, 3);
          scene.remove(b.mesh); bullets.splice(i,1);
          break;
        }
      }
      // Hit Player 2 (Versus Mode)
      if(STATE.mode === 3 && players[1] && !players[1].dead && b.ownerId !== players[1].id) {
         if(b.mesh.position.distanceTo(players[1].mesh.position) < 2) {
           players[1].takeDamage(10);
           scene.remove(b.mesh); bullets.splice(i,1);
         }
      }
    } else {
      // Hit Player
      players.forEach(p => {
        if(!p.dead && b.mesh.position.distanceTo(p.mesh.position) < 2) {
          p.takeDamage(10);
          scene.remove(b.mesh); bullets.splice(i,1);
        }
      });
    }
  }

  // Enemy Logic
  enemies.forEach(e => e.update(dt));
  
  // Spawn Enemies (Wave Logic)
  if(STATE.mode !== 3) { // Don't spawn enemies in PvP
    if(Math.random() < 0.02 && enemies.length < 10) {
      enemies.push(new Enemy(Math.floor(Math.random()*2))); // 0 or 1
    }
    if(STATE.scoreP1 > 500 && !enemies.some(e=>e.type===2)) {
       enemies.push(new Enemy(2)); // Boss
       showMessage("BOSS INCOMING");
    }
  }

  // Particles
  for(let i=particles.length-1; i>=0; i--) {
    const p = particles[i];
    p.position.add(p.userData.vel);
    p.userData.vel.y -= 0.02;
    p.userData.life -= 0.05;
    p.scale.setScalar(p.userData.life);
    if(p.userData.life <= 0) { scene.remove(p); particles.splice(i,1); }
  }

  drawRadar();
}

function checkWinCondition() {
  if(STATE.mode === 3) {
    if(players[0].dead) endGame("P2 WINS");
    if(players[1].dead) endGame("P1 WINS");
  } else {
    if(players.every(p => p.dead)) endGame("GAME OVER");
  }
}

function endGame(msg) {
  STATE.active = false;
  showMessage(msg);
  setTimeout(() => {
    document.getElementById('main-menu').style.display = 'flex';
    document.getElementById('game-ui').style.display = 'none';
    // Reset
    players.forEach(p => scene.remove(p.mesh));
    players = [];
  }, 3000);
}

// --- UI & RADAR ---

function updateHUD() {
  document.getElementById('p1-hp').style.width = players[0].hp + '%';
  if(players[1]) document.getElementById('p2-hp').style.width = players[1].hp + '%';
  document.getElementById('score-display').textContent = "SCORE: " + STATE.scoreP1;
  document.getElementById('lb-score-1').textContent = STATE.scoreP1;
  if(players[1]) document.getElementById('lb-score-2').textContent = STATE.scoreP2;
}

function showMessage(txt) {
  const el = document.getElementById('center-msg');
  el.textContent = txt;
  el.style.opacity = 1;
  setTimeout(() => el.style.opacity = 0, 2000);
}

function drawRadar() {
  const cvs = document.getElementById('radar-canvas');
  const ctx = cvs.getContext('2d');
  ctx.clearRect(0,0,150,150);
  ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
  
  const scale = 1.5; // Radar zoom
  const cx = 75, cy = 75;

  players.forEach(p => {
    if(!p.dead) {
      ctx.fillStyle = p.id===0 ? '#0ff' : '#f00';
      ctx.beginPath();
      ctx.arc(cx + p.mesh.position.x*scale, cy + p.mesh.position.z*scale, 3, 0, Math.PI*2);
      ctx.fill();
    }
  });
  
  ctx.fillStyle = 'rgba(255, 0, 255, 0.7)';
  enemies.forEach(e => {
     ctx.beginPath();
     ctx.arc(cx + e.mesh.position.x*scale, cy + e.mesh.position.z*scale, 2, 0, Math.PI*2);
     ctx.fill();
  });
}

// --- INIT & LOOPS ---

window.startGame = (mode) => {
  STATE.mode = mode;
  STATE.active = true;
  STATE.scoreP1 = 0;
  
  document.getElementById('main-menu').style.display = 'none';
  document.getElementById('game-ui').style.display = 'block';
  
  if(audioCtx.state === 'suspended') audioCtx.resume();

  // Generate Level
  generateLevel(STATE.level);

  // Spawn Players
  players = [];
  players.push(new Player(0, 0x00ffff, new THREE.Vector3(0,0,20)));
  if(mode > 1) {
    players.push(new Player(1, 0xff0000, new THREE.Vector3(0,0,20))); // P2 starts same pos or adjust
    players[1].mesh.position.x = 5;
    document.getElementById('p2-panel').style.display = 'block';
  } else {
    document.getElementById('p2-panel').style.display = 'none';
  }
  
  showMessage("LEVEL " + (STATE.level+1));
};

window.selectLevel = (idx, el) => {
  STATE.level = idx;
  document.querySelectorAll('.level-card').forEach(c => c.classList.remove('active'));
  el.classList.add('active');
};

// Asset Loading
loader.load(MODEL_URL, (gltf) => {
  baseModel = gltf.scene;
  // Extract animations manually if needed
  baseModel.animations = gltf.animations; 
}, undefined, console.error);

// Main Loop
const clock = new THREE.Clock();
function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  updateGame(dt);
  renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();

</script>
</body>
</html>
