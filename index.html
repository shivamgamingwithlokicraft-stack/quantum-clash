<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>QuantumClash 3D - Full Version</title>
<link rel="icon" href="https://cdn-icons-png.flaticon.com/512/616/616408.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
    margin: 0;
    overflow: hidden;
    background: #111;
    font-family: Arial, sans-serif;
}
header {
    position: fixed;
    top: 0;
    width: 100%;
    padding: 12px;
    background: #0ff;
    text-align: center;
    font-weight: bold;
    z-index: 10;
    color: #000;
    text-transform: uppercase;
    letter-spacing: 2px;
}
#ui {
    position: fixed;
    top: 60px;
    left: 10px;
    color: #0ff;
    z-index: 10;
    text-shadow: 1px 1px 0 #000;
    font-size: 14px;
}
#mobile {
    position: fixed;
    bottom: 20px;
    width: 100%;
    display: flex;
    justify-content: space-around;
    z-index: 20;
    pointer-events: none;
}
.btn {
    background: rgba(0, 255, 255, 0.2);
    border: 2px solid #0ff;
    color: #0ff;
    padding: 15px;
    border-radius: 50%;
    font-weight: bold;
    pointer-events: auto;
    cursor: pointer;
    width: 60px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    user-select: none;
    backdrop-filter: blur(4px);
}
.btn:active {
    background: #0ff;
    color: #000;
}
#flash {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #fff;
    opacity: 0;
    z-index: 50;
    pointer-events: none;
}
</style>
</head>

<body>
<header>QuantumClash 3D</header>
<div id="flash"></div>

<div id="ui">
  <div id="score" style="font-size: 1.2em; margin-bottom: 5px;">Score: 0</div>
  <div id="p1">Player Health: 100</div>
  <div id="boss" style="color:#f00; margin-top:5px;">Boss Health: 200</div>
</div>

<div id="mobile">
  <div class="btn" id="left">â—€</div>
  <div class="btn" id="shoot">ðŸ”¥</div>
  <div class="btn" id="right">â–¶</div>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157/build/three.module.js';

/* =================================
            SCENE SETUP
================================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050510);
scene.fog = new THREE.Fog(0x050510, 20, 120);

const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 15, 40);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

/* =================================
            LIGHTING
================================= */
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(10, 20, 10);
dirLight.castShadow = true;
scene.add(dirLight);

const blueLight = new THREE.PointLight(0x00ffff, 2, 50);
blueLight.position.set(-10, 5, -10);
scene.add(blueLight);

const redLight = new THREE.PointLight(0xff0000, 2, 50);
redLight.position.set(10, 5, -20);
scene.add(redLight);

/* =================================
            FLOOR
================================= */
const gridHelper = new THREE.GridHelper(100, 50, 0x00ffff, 0x222222);
scene.add(gridHelper);

const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8, metalness: 0.2 });
const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), floorMaterial);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

/* =================================
            FLASH EFFECT
================================= */
const flashEl = document.getElementById("flash");

/* =================================
            ROBOT CREATOR
================================= */
function createRobot(color, scale = 1) {
    const group = new THREE.Group();

    // Materials
    const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3 });
    const darkMat = new THREE.MeshStandardMaterial({ color: 0x333333 });

    // Body
    const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 0.6), mat);
    body.position.y = 1.5;
    body.castShadow = true;
    group.add(body);

    // Head
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), darkMat);
    head.position.y = 2.6;
    group.add(head);

    // Arms
    const armL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1, 0.4), darkMat);
    armL.position.set(-0.7, 1.5, 0);
    group.add(armL);

    const armR = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1, 0.4), darkMat);
    armR.position.set(0.7, 1.5, 0);
    group.add(armR);

    // Eyes
    const eyeGeo = new THREE.BoxGeometry(0.5, 0.1, 0.1);
    const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const eyes = new THREE.Mesh(eyeGeo, eyeMat);
    eyes.position.set(0, 2.6, 0.36);
    group.add(eyes);

    group.userData = { body, head, armL, armR, eyes };
    group.scale.set(scale, scale, scale);

    return group;
}

/* =================================
            GAME VARIABLES
================================= */
let player = createRobot(0x00ffff, 2);
player.position.set(0, 0, 10);
scene.add(player);

let boss = createRobot(0xff0000, 4);
boss.position.set(0, 0, -25);
scene.add(boss);

let bullets = [];
let enemies = [];
let particles = [];

let score = 0;
let playerHealth = 100;
let bossHealth = 200;
let level = 1;
let isGameOver = false;
let enemySpawnRate = 2000;
let lastEnemySpawn = 0;
let lastBossShot = 0;

let moveDirection = 0;
let canShoot = true;
let shakeIntensity = 0;

/* =================================
            BULLET SYSTEM
================================= */
function shootBullet(position, velocity, color, owner) {
    const geo = new THREE.SphereGeometry(0.35);
    const mat = new THREE.MeshBasicMaterial({ color: color });
    const bullet = new THREE.Mesh(geo, mat);
    bullet.position.copy(position);
    bullet.position.y += 1.6;
    bullet.userData = { velocity: velocity.clone(), owner: owner };
    scene.add(bullet);
    bullets.push(bullet);

    // Animate player arm recoil
    if(owner === "player") player.userData.armR.rotation.x = -0.8;
}

/* =================================
            PARTICLE SYSTEM
================================= */
function createExplosion(position, color) {
    flashEl.style.opacity = 0.3;
    setTimeout(() => { flashEl.style.opacity = 0; }, 50);

    for(let i = 0; i < 12; i++) {
        const geo = new THREE.BoxGeometry(0.25, 0.25, 0.25);
        const mat = new THREE.MeshBasicMaterial({ color: color });
        const particle = new THREE.Mesh(geo, mat);
        particle.position.copy(position);
        particle.userData = {
            velocity: new THREE.Vector3((Math.random() - 0.5) * 0.6, Math.random() * 0.6, (Math.random() - 0.5) * 0.6),
            life: 1
        };
        scene.add(particle);
        particles.push(particle);
    }
}

/* =================================
            ENEMY SPAWNING
================================= */
function spawnEnemy(time) {
    if(isGameOver) return;
    if(time - lastEnemySpawn > enemySpawnRate) {
        const e = createRobot(0xff8800, 1.6);
        e.position.set(Math.random() * 30 - 15, 0, -45);
        scene.add(e);
        enemies.push(e);
        lastEnemySpawn = time;
    }
}

/* =================================
            BOSS AI
================================= */
function bossAI(time) {
    if(!boss || isGameOver) return;

    // Side-to-side movement
    boss.position.x = Math.sin(time * 0.0015) * 12;
    boss.position.y = Math.sin(time * 0.002) * 0.3;

    // Shooting pattern
    let interval = bossHealth < 100 ? 600 : 1000;
    if(time - lastBossShot > interval) {
        const shots = bossHealth < 100 ? 3 : 1;
        for(let i=0; i<shots; i++) {
            const angle = (i-1)*0.15;
            shootBullet(boss.position, new THREE.Vector3(Math.sin(angle),0,1).normalize().multiplyScalar(1.4), 0xff00ff, "boss");
        }
        lastBossShot = time;
    }
}

/* =================================
            PLAYER CONTROLS
================================= */
function firePlayer() {
    if(!canShoot || isGameOver) return;
    shootBullet(player.position, new THREE.Vector3(0, 0, -1), 0xffff00, "player");
    canShoot = false;
    player.userData.armR.rotation.x = -0.8;
    setTimeout(() => { canShoot = true; }, 300);
}

function movePlayer(dir) {
    if(!player || isGameOver) return;
    player.position.x += dir;
    player.position.x = Math.max(-16, Math.min(16, player.position.x));
}

// Keyboard
window.addEventListener("keydown", e => {
    if(e.key === "ArrowLeft") moveDirection = -1;
    if(e.key === "ArrowRight") moveDirection = 1;
    if(e.code === "Space") firePlayer();
});

window.addEventListener("keyup", e => { moveDirection = 0; });

// Mobile
document.getElementById("left").ontouchstart = e => { e.preventDefault(); moveDirection = -1; };
document.getElementById("right").ontouchstart = e => { e.preventDefault(); moveDirection = 1; };
document.getElementById("shoot").ontouchstart = e => { e.preventDefault(); firePlayer(); };
document.getElementById("left").ontouchend = document.getElementById("right").ontouchend = () => { moveDirection = 0; };

/* =================================
            CAMERA SHAKE
================================= */
function shakeCamera(intensity=0.3) {
    shakeIntensity = intensity;
}

function applyCameraShake() {
    if(shakeIntensity > 0) {
        camera.position.x += (Math.random() - 0.5) * shakeIntensity;
        camera.position.y += (Math.random() - 0.5) * shakeIntensity;
        shakeIntensity *= 0.85;
    }
}

/* =================================
            GAME LOOP
================================= */
const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);

    const time = Date.now();
    const delta = clock.getDelta();

    if(isGameOver) {
        renderer.render(scene, camera);
        return;
    }

    bossAI(time);
    spawnEnemy(time);

    // Player movement
    player.position.x += moveDirection * 0.6;
    player.position.y = Math.sin(time * 0.005) * 0.2;
    player.userData.armR.rotation.x *= 0.9;

    // Update bullets
    for(let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.position.add(b.userData.velocity);

        if(b.position.z < -60 || b.position.z > 60) {
            scene.remove(b);
            bullets.splice(i, 1);
            continue;
        }

        if(b.userData.owner === "player") {
            const distBoss = b.position.distanceTo(boss.position);
            if(distBoss < 3) {
                bossHealth -= 5;
                createExplosion(b.position, 0xff0033);
                shakeCamera(0.25);
                scene.remove(b);
                bullets.splice(i,1);
            }
        } else if(b.userData.owner === "boss") {
            const distPlayer = b.position.distanceTo(player.position);
            if(distPlayer < 2) {
                playerHealth -= 10;
                createExplosion(player.position, 0x00ffff);
                shakeCamera(0.2);
                scene.remove(b);
                bullets.splice(i,1);
            }
        }
    }

    // Update enemies
    for(let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        e.position.z += 0.15;
        e.userData.body.rotation.y += 0.05;
        e.position.y = Math.sin(time*0.01 + i) * 0.1;

        if(e.position.distanceTo(player.position) < 2) {
            playerHealth -= 5;
            createExplosion(e.position, 0xff8800);
            scene.remove(e);
            enemies.splice(i, 1);
        }
    }

    // Update particles
    for(let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.position.add(p.userData.velocity);
        p.userData.life -= 0.05;
        p.scale.setScalar(p.userData.life);
        if(p.userData.life <= 0) {
            scene.remove(p);
            particles.splice(i, 1);
        }
    }

    // Level progression
    score++;
    if(bossHealth <= 0 && !isGameOver) {
        level++;
        bossHealth = 200 + level*50;
        enemySpawnRate = Math.max(800, enemySpawnRate - 150);
        boss.position.set(0,0,-28);
    }

    // Update UI
    document.getElementById("score").innerText = "Score: " + score;
    document.getElementById("p1").innerText = "Player Health: " + playerHealth;
    document.getElementById("boss").innerText = "Boss Health: " + bossHealth;

    // Game over
    if(playerHealth <= 0) {
        isGameOver = true;
        document.querySelector("header").innerText = "GAME OVER";
    }

    // Camera shake
    applyCameraShake();

    // Render
    renderer.render(scene, camera);
}

animate();

/* =================================
            WINDOW RESIZE
================================= */
window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>

