<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>QuantumClash 3D - Ultimate</title>
<link rel="icon" href="https://cdn-icons-png.flaticon.com/512/616/616408.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
  body { margin:0; overflow:hidden; background:#050505; font-family:'Segoe UI', sans-serif; user-select: none; }
  
  /* HUD UI */
  #hud {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
    display: flex; flex-direction: column; justify-content: space-between;
  }
  
  header { 
    padding: 20px; 
    background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
    text-align: center; z-index: 10;
  }
  
  h1 { 
    color: #0ff; margin: 0; text-transform: uppercase; letter-spacing: 8px; 
    font-size: 2rem; text-shadow: 0 0 20px #0ff;
  }

  .stats-panel {
    padding: 30px;
    color: white;
    font-size: 1.2rem;
    font-weight: bold;
    text-shadow: 1px 1px 4px #000;
  }

  .bar-container {
    width: 300px; height: 10px; background: #333; margin-top: 5px; border: 1px solid #555;
  }
  .bar-fill { height: 100%; transition: width 0.2s; }
  #p1-bar { background: #0ff; width: 100%; box-shadow: 0 0 10px #0ff; }
  #boss-bar { background: #f00; width: 100%; box-shadow: 0 0 10px #f00; }

  /* START SCREEN */
  #start-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.9);
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 100; backdrop-filter: blur(10px);
    pointer-events: auto;
  }

  #start-btn {
    background: transparent;
    color: #0ff;
    font-family: inherit;
    font-size: 2.5rem;
    padding: 20px 60px;
    border: 2px solid #0ff;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 5px;
    box-shadow: 0 0 20px #0ff inset, 0 0 40px #0ff;
    transition: 0.3s;
  }
  #start-btn:hover {
    background: #0ff; color: #000; box-shadow: 0 0 60px #0ff;
  }
  
  .instructions { margin-top: 20px; color: #aaa; font-size: 0.9rem; }
</style>

<!-- Import Map -->
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>
</head>

<body>

<div id="start-screen">
  <h1 style="font-size:4rem; margin-bottom:20px;">QUANTUM CLASH</h1>
  <button id="start-btn">ENGAGE SYSTEM</button>
  <div class="instructions">[A/D] or [←/→] to Move &nbsp;|&nbsp; [SPACE] to Fire</div>
</div>

<div id="hud">
  <header>
    <h1 id="game-title">QUANTUM CLASH</h1>
  </header>
  <div class="stats-panel">
    <div>PLAYER INTEGRITY</div>
    <div class="bar-container"><div id="p1-bar" class="bar-fill"></div></div>
    <div id="score-display" style="margin-top:20px;">SCORE: 000000</div>
  </div>
  <div class="stats-panel" style="align-self: flex-end; text-align: right;">
    <div>TARGET INTEGRITY</div>
    <div class="bar-container"><div id="boss-bar" class="bar-fill"></div></div>
  </div>
</div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

// --- CONFIGURATION ---
const SETTINGS = {
  playerSpeed: 0.3,
  playerLimitX: 15,
  bossSpeed: 0.05,
  bulletSpeed: 1.2
};

// --- STATE ---
let gameState = 'start'; // start, playing, gameover
let playerMixer, bossMixer;
let playerActions = {}, bossActions = {};
let activeAction = 'Idle';
let lastShotTime = 0;

const keys = { left: false, right: false };

// --- AUDIO SYSTEM (Procedural) ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const Sound = {
  shoot: () => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(800, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.15);
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.15);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.15);
  },
  explosion: () => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(100, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(1, audioCtx.currentTime + 0.3);
    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.3);
  },
  startMusic: () => {
    // Simple drone
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.value = 50;
    gain.gain.value = 0.05;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
  }
};

// --- SCENE SETUP ---
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x050505, 0.02);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 8, 20);
camera.lookAt(0, 2, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// --- LIGHTING & ENVIRONMENT ---
const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
hemiLight.position.set(0, 20, 0);
scene.add(hemiLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 2);
dirLight.position.set(-10, 20, 10);
dirLight.castShadow = true;
dirLight.shadow.camera.top = 20;
dirLight.shadow.camera.bottom = -20;
dirLight.shadow.camera.left = -20;
dirLight.shadow.camera.right = 20;
scene.add(dirLight);

// Neon Lights for aesthetics
const pLight1 = new THREE.PointLight(0x00ffff, 5, 50);
pLight1.position.set(-15, 5, -5);
scene.add(pLight1);
const pLight2 = new THREE.PointLight(0xff00ff, 5, 50);
pLight2.position.set(15, 5, -15);
scene.add(pLight2);

// Reflective Floor
const floorGeo = new THREE.PlaneGeometry(100, 100);
const floorMat = new THREE.MeshStandardMaterial({ 
  color: 0x111111, 
  roughness: 0.1, 
  metalness: 0.8 
});
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

const grid = new THREE.GridHelper(100, 50, 0x00ffff, 0x222222);
grid.position.y = 0.01;
scene.add(grid);

// Background Particles (Stars)
const starsGeo = new THREE.BufferGeometry();
const starCount = 2000;
const starPos = new Float32Array(starCount * 3);
for(let i=0; i<starCount*3; i++) {
  starPos[i] = (Math.random() - 0.5) * 200;
}
starsGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
const stars = new THREE.Points(starsGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.2}));
scene.add(stars);

// --- GAME OBJECTS ---
const bullets = [];
const enemies = [];
const particles = [];
let player, boss;
let stats = { score: 0, hp: 100, bossHp: 200 };

// --- MODEL LOADING ---
const loader = new GLTFLoader();
const MODEL_URL = "https://quantum-clash.vercel.app/assets/models/RobotExpressive.glb";

loader.load(MODEL_URL, (gltf) => {
  const model = gltf.scene;

  // 1. CREATE PLAYER
  player = new THREE.Group();
  const pMesh = model.clone();
  
  // Color Player Cyan
  pMesh.traverse(c => {
    if(c.isMesh) {
      c.material = c.material.clone();
      c.material.color.setHex(0x00ffff);
      c.castShadow = true;
      c.receiveShadow = true;
    }
  });
  pMesh.position.y = 0; // Center the model in the group
  player.add(pMesh);
  player.position.set(0, 0, 10);
  scene.add(player);

  // Setup Player Animations
  playerMixer = new THREE.AnimationMixer(pMesh);
  const idleClip = THREE.AnimationClip.findByName(gltf.animations, 'Idle');
  const runClip = THREE.AnimationClip.findByName(gltf.animations, 'Running');
  const deathClip = THREE.AnimationClip.findByName(gltf.animations, 'Death');

  if(idleClip) playerActions['Idle'] = playerMixer.clipAction(idleClip);
  if(runClip) playerActions['Running'] = playerMixer.clipAction(runClip);
  
  // Start with Idle
  playerActions['Idle'].play();

  // 2. CREATE BOSS
  boss = new THREE.Group();
  const bMesh = model.clone();
  bMesh.scale.set(2,2,2); // Bigger
  
  // Color Boss Red
  bMesh.traverse(c => {
    if(c.isMesh) {
      c.material = c.material.clone();
      c.material.color.setHex(0xff0000);
      c.castShadow = true;
      c.receiveShadow = true;
    }
  });
  boss.add(bMesh);
  boss.position.set(0, 0, -20);
  scene.add(boss);

  // Setup Boss Animations
  bossMixer = new THREE.AnimationMixer(bMesh);
  const bossIdle = THREE.AnimationClip.findByName(gltf.animations, 'Idle');
  if(bossIdle) {
    const act = bossMixer.clipAction(bossIdle);
    act.play();
  }

}, undefined, (err) => {
  console.error(err);
});

// --- GAMEPLAY FUNCTIONS ---

function switchAnimation(actionName) {
  if (activeAction === actionName) return;
  const lastAction = playerActions[activeAction];
  const nextAction = playerActions[actionName];

  if (lastAction && nextAction) {
    lastAction.fadeOut(0.2);
    nextAction.reset().fadeIn(0.2).play();
    activeAction = actionName;
  }
}

function spawnBullet(pos, isPlayer) {
  const geo = new THREE.SphereGeometry(0.3);
  const mat = new THREE.MeshBasicMaterial({ color: isPlayer ? 0xffff00 : 0xff00ff });
  const mesh = new THREE.Mesh(geo, mat);
  
  mesh.position.copy(pos);
  mesh.position.y += 1.5; // Shoot from chest level
  
  mesh.userData = {
    velocity: new THREE.Vector3(0, 0, isPlayer ? -SETTINGS.bulletSpeed : SETTINGS.bulletSpeed * 0.8),
    isPlayer: isPlayer
  };
  
  scene.add(mesh);
  bullets.push(mesh);
}

function createExplosion(pos, color) {
  Sound.explosion();
  for(let i=0; i<15; i++) {
    const geo = new THREE.TetrahedronGeometry(0.2);
    const mat = new THREE.MeshBasicMaterial({ color: color });
    const p = new THREE.Mesh(geo, mat);
    p.position.copy(pos);
    p.userData = {
      vel: new THREE.Vector3((Math.random()-0.5)*0.8, (Math.random())*0.8, (Math.random()-0.5)*0.8),
      life: 1.0
    };
    scene.add(p);
    particles.push(p);
  }
}

function spawnEnemy() {
  if(!player) return;
  // Simple geometry enemy to save performance compared to cloning complex GLTF constantly
  const geo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
  const mat = new THREE.MeshStandardMaterial({ color: 0xffaa00 });
  const e = new THREE.Mesh(geo, mat);
  e.position.set((Math.random()-0.5)*20, 0.75, -40);
  scene.add(e);
  enemies.push(e);
}

// --- CONTROLS ---
window.addEventListener('keydown', (e) => {
  if(e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
  if(e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
  if(e.code === 'Space' && gameState === 'playing') {
    const now = Date.now();
    if(now - lastShotTime > 200) { // Fire rate limit
      spawnBullet(player.position, true);
      Sound.shoot();
      lastShotTime = now;
    }
  }
});

window.addEventListener('keyup', (e) => {
  if(e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
  if(e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
});

document.getElementById('start-btn').addEventListener('click', () => {
  document.getElementById('start-screen').style.display = 'none';
  if(audioCtx.state === 'suspended') audioCtx.resume();
  Sound.startMusic();
  gameState = 'playing';
});

// --- MAIN LOOP ---
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  const time = Date.now();

  // Mixers Update
  if(playerMixer) playerMixer.update(dt);
  if(bossMixer) bossMixer.update(dt);

  if (gameState === 'playing') {
    
    // --- PLAYER MOVEMENT & ANIMATION ---
    if(player) {
      let moving = false;
      
      if(keys.left) {
        player.position.x -= SETTINGS.playerSpeed;
        player.rotation.y = THREE.MathUtils.lerp(player.rotation.y, Math.PI / 2, 0.1); // Face Left
        moving = true;
      }
      if(keys.right) {
        player.position.x += SETTINGS.playerSpeed;
        player.rotation.y = THREE.MathUtils.lerp(player.rotation.y, -Math.PI / 2, 0.1); // Face Right
        moving = true;
      }

      // Clamp position
      player.position.x = Math.max(-SETTINGS.playerLimitX, Math.min(SETTINGS.playerLimitX, player.position.x));

      // Switch Animations
      if(moving) {
        switchAnimation('Running');
        // Add subtle bob
        player.position.y = Math.abs(Math.sin(time * 0.01)) * 0.2;
      } else {
        switchAnimation('Idle');
        // Return to neutral rotation
        player.rotation.y = THREE.MathUtils.lerp(player.rotation.y, 0, 0.1);
        player.position.y = 0;
      }
    }

    // --- BOSS LOGIC ---
    if(boss) {
      // Hover movement
      boss.position.x = Math.sin(time * 0.001) * 8;
      boss.position.y = Math.sin(time * 0.002) * 1; 
      
      // Boss Shooting
      if(Math.random() < 0.01) {
        spawnBullet(boss.position, false);
      }
    }

    // --- BULLETS ---
    for(let i=bullets.length-1; i>=0; i--) {
      const b = bullets[i];
      b.position.add(b.userData.velocity);

      // Cull
      if(b.position.z < -50 || b.position.z > 50) {
        scene.remove(b); bullets.splice(i,1); continue;
      }

      // Collisions
      if(b.userData.isPlayer) {
        // Hit Boss
        if(boss && b.position.distanceTo(boss.position) < 4) {
          stats.bossHp -= 2;
          createExplosion(b.position, 0xff0000);
          scene.remove(b); bullets.splice(i,1);
          
          // Boss Reaction
          const bossMesh = boss.children[0];
          bossMesh.rotation.x = Math.PI/4; // Flinch
          setTimeout(() => bossMesh.rotation.x = 0, 200);

          if(stats.bossHp <= 0) endGame(true);
        }
        // Hit Minions
        for(let j=enemies.length-1; j>=0; j--) {
          if(b.position.distanceTo(enemies[j].position) < 2) {
            createExplosion(enemies[j].position, 0xffaa00);
            scene.remove(enemies[j]); enemies.splice(j,1);
            stats.score += 500;
            scene.remove(b); bullets.splice(i,1);
            break;
          }
        }
      } else {
        // Hit Player
        if(player && b.position.distanceTo(player.position) < 2) {
          stats.hp -= 5;
          createExplosion(player.position, 0x00ffff);
          scene.remove(b); bullets.splice(i,1);
          if(stats.hp <= 0) endGame(false);
        }
      }
    }

    // --- ENEMIES ---
    // Spawn occasionally
    if(Math.random() < 0.005) spawnEnemy();

    enemies.forEach((e, i) => {
      e.position.z += 0.2;
      if(e.position.distanceTo(player.position) < 2) {
        stats.hp -= 10;
        createExplosion(e.position, 0xffaa00);
        scene.remove(e); enemies.splice(i,1);
      }
    });

    // --- PARTICLES ---
    for(let i=particles.length-1; i>=0; i--) {
      const p = particles[i];
      p.position.add(p.userData.vel);
      p.userData.vel.y -= 0.05; // Gravity
      p.rotation.x += 0.1;
      p.userData.life -= 0.02;
      p.scale.setScalar(p.userData.life);
      if(p.userData.life <= 0) {
        scene.remove(p); particles.splice(i,1);
      }
    }

    // --- UI UPDATE ---
    document.getElementById('p1-bar').style.width = stats.hp + '%';
    document.getElementById('boss-bar').style.width = (stats.bossHp / 2) + '%'; // Max boss hp 200, bar 100%
    document.getElementById('score-display').textContent = 'SCORE: ' + stats.score.toString().padStart(6, '0');
  }

  // Background Star Animation
  const pos = stars.geometry.attributes.position.array;
  for(let i=2; i<pos.length; i+=3) {
    pos[i] += 0.5;
    if(pos[i] > 20) pos[i] = -100;
  }
  stars.geometry.attributes.position.needsUpdate = true;

  renderer.render(scene, camera);
}

function endGame(victory) {
  gameState = 'gameover';
  const h1 = document.getElementById('game-title');
  h1.textContent = victory ? "MISSION COMPLETE" : "CRITICAL FAILURE";
  h1.style.color = victory ? "#0f0" : "#f00";
  setTimeout(() => {
    alert(victory ? "VICTORY! Score: " + stats.score : "GAME OVER");
    location.reload();
  }, 100);
}

// Resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();

</script>
</body>
</html>
