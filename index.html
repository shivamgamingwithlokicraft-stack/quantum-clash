<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>QuantumClash 3D</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  body { margin:0; overflow:hidden; background:#000; font-family:'Orbitron', sans-serif; color:white; user-select:none; }
  
  /* --- CINEMATIC HUD --- */
  #game-ui { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:none; 
    box-shadow: inset 0 0 100px rgba(0,0,0,0.8); z-index: 10; }
  
  .hud-top { 
    position: absolute; top:0; width:100%; height: 80px; 
    display:flex; justify-content:space-between; align-items: center; 
    padding:0 40px; box-sizing:border-box; 
    background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent);
  }
  
  .player-hud { display:flex; flex-direction:column; width: 300px; }
  .p1-label { color:#0ff; text-shadow: 0 0 15px #0ff; font-weight:700; margin-bottom:5px; }
  .p2-label { color:#f00; text-shadow: 0 0 15px #f00; font-weight:700; margin-bottom:5px; text-align:right; }
  
  .hp-bar-bg { width:100%; height:12px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.3); transform: skewX(-20deg); overflow:hidden; }
  .hp-bar-fill { height:100%; width:100%; transition:width 0.2s cubic-bezier(0.1, 0.7, 1.0, 0.1); }
  .fill-p1 { background: linear-gradient(90deg, #00ffff, #0088ff); box-shadow: 0 0 20px #00ffff; }
  .fill-p2 { background: linear-gradient(90deg, #ff0000, #ff8800); box-shadow: 0 0 20px #ff0000; }

  #center-notify { position:absolute; top:40%; width:100%; text-align:center; font-size:4rem; 
    text-shadow: 0 0 30px rgba(255,255,255,0.8); letter-spacing: 10px; 
    opacity:0; transition: opacity 1s; transform: scale(1.2); }
  
  #radar-box { position:absolute; bottom:30px; right:30px; width:180px; height:180px; 
    border: 2px solid rgba(0, 255, 0, 0.5); border-radius: 50%; 
    background: radial-gradient(circle, rgba(0,50,0,0.4) 0%, rgba(0,0,0,0.8) 100%);
    box-shadow: 0 0 20px rgba(0,255,0,0.2); overflow:hidden; backdrop-filter: blur(2px);
  }
  #radar-canvas { width:100%; height:100%; mix-blend-mode: screen; }

  #level-ind { position:absolute; bottom:30px; left:30px; color:#fff; font-size:1.5rem; text-shadow:0 0 10px white; }

  #producer-credit {
    position: absolute; bottom: 10px; width: 100%; text-align: center;
    color: rgba(0, 255, 255, 0.6); font-size: 0.8rem; letter-spacing: 2px;
    text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
    pointer-events: none; z-index: 20;
  }
  
  /* --- MENU SCREEN (Updated for 3D BG) --- */
  #menu-screen { 
    position:fixed; top:0; left:0; width:100%; height:100%; 
    /* CHANGED: Removed static gradient, now transparent to show WebGL BG */
    background: rgba(0, 0, 0, 0.3); 
    backdrop-filter: blur(4px); /* Blur background slightly for readability */
    z-index:100; 
    display:flex; flex-direction:column; align-items:center; justify-content:center; pointer-events:auto; 
    transition: opacity 0.5s;
  }
  
  h1 { font-size:6rem; margin:0; background: linear-gradient(to right, #0ff, #f0f); -webkit-background-clip: text; color:transparent; text-shadow: 0 0 50px rgba(0,255,255,0.5); }
  
  .menu-btn {
    background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); 
    color: #fff; padding: 20px 60px; margin: 15px; font-size: 1.5rem; font-family: inherit; 
    cursor: pointer; transition: 0.3s; text-transform: uppercase; letter-spacing: 4px;
    backdrop-filter: blur(5px); clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
  }
  .menu-btn:hover { background: #0ff; color: #000; border-color: #0ff; box-shadow: 0 0 30px #0ff; transform: translateY(-5px); }

  .level-select { display:flex; gap:20px; margin-bottom:40px; }
  .level-opt { padding:10px 20px; border:1px solid #555; cursor:pointer; opacity:0.5; transition:0.3s; }
  .level-opt:hover, .level-opt.active { opacity:1; border-color:#0ff; background:rgba(0,255,255,0.1); box-shadow:0 0 15px #0ff; }

</style>

<!-- Import Map -->
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>
</head>
<body>

<!-- MENU (3D Background visible behind) -->
<div id="menu-screen">
  <h1>QUANTUM CLASH</h1>
  <div class="level-select">
    <div class="level-opt active" onclick="setLevel(0, this)">NEBULA</div>
    <div class="level-opt" onclick="setLevel(1, this)">CYBER CITY</div>
    <div class="level-opt" onclick="setLevel(2, this)">ASTEROID</div>
  </div>
  <button class="menu-btn" onclick="startGame(1)">1 PLAYER</button>
  <button class="menu-btn" onclick="startGame(2)">2 PLAYER CO-OP</button>
  <div style="margin-top:30px; color:#ccc; font-size:0.8rem; text-shadow:0 0 5px black;">
    WASD to Move | SPACE to Shoot (P1)<br>
    ARROWS to Move | ENTER to Shoot (P2)
  </div>
</div>

<!-- HUD -->
<div id="game-ui">
  <div class="hud-top">
    <div class="player-hud">
      <div class="p1-label">CYAN WARRIOR</div>
      <div class="hp-bar-bg"><div id="p1-hp" class="hp-bar-fill fill-p1"></div></div>
    </div>
    
    <div id="center-notify">WAVE START</div>
    
    <div class="player-hud" id="p2-hud-container" style="display:none; align-items:flex-end;">
      <div class="p2-label">CRIMSON WARRIOR</div>
      <div class="hp-bar-bg"><div id="p2-hp" class="hp-bar-fill fill-p2"></div></div>
    </div>
  </div>
  
  <div id="level-ind">SECTOR: NEBULA</div>

  <div id="radar-box">
    <canvas id="radar-canvas" width="200" height="200"></canvas>
  </div>

  <div id="producer-credit">Produced by Shivam Singh Patel</div>
</div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// --- SETUP ---
const scene = new THREE.Scene();
// Default fog for game
scene.fog = new THREE.FogExp2(0x000000, 0.02);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
// Initial Menu Camera Position (Cinematic low angle)
camera.position.set(0, 5, 25);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.toneMapping = THREE.ReinhardToneMapping;
document.body.appendChild(renderer.domElement);

// --- POST PROCESSING ---
const renderScene = new RenderPass(scene, camera);
const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
bloomPass.threshold = 0.1;
bloomPass.strength = 1.8; 
bloomPass.radius = 0.5;

const composer = new EffectComposer(renderer);
composer.addPass(renderScene);
composer.addPass(bloomPass);

// --- GAME STATE ---
const GAME = { active: false, mode: 1, levelIdx: 0, score: 0 };
const PLAYERS = [];
const BULLETS = [];
const ENEMIES = [];
const PARTICLES = [];
const LEVEL_OBJECTS = [];

// --- ASSETS ---
const MODEL_URL = "https://quantum-clash.vercel.app/assets/models/RobotExpressive.glb";
let baseRobotModel;

const loader = new GLTFLoader();
loader.load(MODEL_URL, (gltf) => {
  baseRobotModel = gltf.scene;
  baseRobotModel.traverse(c => {
    if (c.isMesh) {
      c.castShadow = true;
      c.receiveShadow = true;
    }
  });
});

// --- AUDIO ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const Sound = {
  play: (freq, type, duration) => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + duration);
  },
  shoot: () => Sound.play(800, 'sawtooth', 0.1),
  hit: () => Sound.play(200, 'square', 0.1),
  explosion: () => Sound.play(50, 'sawtooth', 0.4)
};

// --- MENU BACKGROUND OBJECTS ---
// These are always present for the background effect
const starGeo = new THREE.BufferGeometry();
const starCount = 3000;
const starPos = [];
for(let i=0; i<starCount*3; i++) {
  starPos.push((Math.random()-0.5)*200, (Math.random()-0.5)*100, (Math.random()-0.5)*200);
}
starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color:0xffffff, size:0.2, transparent:true, opacity:0.8}));
scene.add(stars);

// The "Quantum Core" for the menu background
const coreGeo = new THREE.IcosahedronGeometry(3, 1);
const coreMat = new THREE.MeshStandardMaterial({ 
  color: 0x220044, emissive: 0xff00ff, emissiveIntensity: 2, wireframe: true 
});
const menuCore = new THREE.Mesh(coreGeo, coreMat);
scene.add(menuCore);

// --- CLASSES ---

class Player {
  constructor(id, color, startPos) {
    this.id = id;
    this.color = new THREE.Color(color);
    this.hp = 100;
    this.dead = false;
    this.mesh = baseRobotModel.clone();
    this.mesh.scale.set(1.5, 1.5, 1.5);
    
    this.mesh.traverse(c => {
      if(c.isMesh) {
        c.material = c.material.clone();
        c.material.color.setHex(0x222222); 
        c.material.emissive = this.color;  
        c.material.emissiveIntensity = 0.8;
        c.material.roughness = 0.2;
        c.material.metalness = 0.9;
      }
    });

    this.mesh.position.copy(startPos);
    scene.add(this.mesh);
    
    this.light = new THREE.PointLight(this.color, 2, 15);
    this.mesh.add(this.light);
  }

  update(dt, input) {
    if(this.dead) return;
    
    const speed = 20 * dt;
    let moving = false;
    
    if(input.up) { this.mesh.position.z -= speed; moving = true; }
    if(input.down) { this.mesh.position.z += speed; moving = true; }
    if(input.left) { this.mesh.position.x -= speed; moving = true; this.mesh.rotation.y = THREE.MathUtils.lerp(this.mesh.rotation.y, Math.PI/2, 0.2); }
    if(input.right) { this.mesh.position.x += speed; moving = true; this.mesh.rotation.y = THREE.MathUtils.lerp(this.mesh.rotation.y, -Math.PI/2, 0.2); }

    if(moving) {
      if(this.id === 0) { 
        this.mesh.position.y = Math.abs(Math.sin(Date.now() * 0.008)) * 0.5;
      } else { 
        this.mesh.position.y = Math.abs(Math.sin(Date.now() * 0.03)) * 0.3 + (Math.random()*0.1 - 0.05); 
        if(Math.random() > 0.7) spawnParticle(this.mesh.position, 0xff4400, 0.2);
      }
    } else {
      this.mesh.rotation.y = THREE.MathUtils.lerp(this.mesh.rotation.y, 0, 0.1);
      this.mesh.position.y = 0;
    }
  }

  takeDamage(amt) {
    this.hp -= amt;
    Sound.hit();
    this.mesh.traverse(c => { if(c.isMesh) c.material.emissive.setHex(0xffffff); });
    setTimeout(() => { 
      if(this.mesh) this.mesh.traverse(c => { if(c.isMesh) c.material.emissive.copy(this.color); });
    }, 100);
    updateHUD();

    if(this.hp <= 0) this.die();
  }

  die() {
    this.dead = true;
    createExplosion(this.mesh.position, this.color, 30);
    scene.remove(this.mesh);
  }
}

class Enemy {
  constructor() {
    this.hp = 30;
    const geo = new THREE.ConeGeometry(1, 2, 4);
    const mat = new THREE.MeshStandardMaterial({ 
      color: 0x220000, emissive: 0xff0000, emissiveIntensity: 1, roughness: 0.4 
    });
    this.mesh = new THREE.Mesh(geo, mat);
    
    const angle = Math.random() * Math.PI * 2;
    const r = 40;
    this.mesh.position.set(Math.cos(angle)*r, 1, Math.sin(angle)*r);
    scene.add(this.mesh);
    
    const light = new THREE.PointLight(0xff0000, 1, 10);
    this.mesh.add(light);
  }

  update(dt) {
    let target = null;
    let minDist = 999;
    PLAYERS.forEach(p => {
      if(!p.dead) {
        const d = p.mesh.position.distanceTo(this.mesh.position);
        if(d < minDist) { minDist = d; target = p; }
      }
    });

    if(target) {
      const dir = new THREE.Vector3().subVectors(target.mesh.position, this.mesh.position).normalize();
      this.mesh.position.add(dir.multiplyScalar(5 * dt));
      this.mesh.lookAt(target.mesh.position);
    }
  }
}

// --- LEVELS ---

function clearLevel() {
  LEVEL_OBJECTS.forEach(o => scene.remove(o));
  LEVEL_OBJECTS.length = 0;
  // Keep stars and menuCore
}

function createNebulaLevel() {
  scene.fog.color.setHex(0x110022);
  scene.background = new THREE.Color(0x050010);
  
  const grid = new THREE.GridHelper(80, 40, 0xff00ff, 0x220022);
  scene.add(grid); LEVEL_OBJECTS.push(grid);

  const geo = new THREE.BoxGeometry(3, 0.2, 3);
  const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.3 });
  for(let i=0; i<10; i++) {
    const p = new THREE.Mesh(geo, mat);
    p.position.set((Math.random()-0.5)*60, 2, (Math.random()-0.5)*60);
    p.userData = { speed: Math.random() * 0.02 + 0.01, offset: Math.random() * 100 };
    scene.add(p); LEVEL_OBJECTS.push(p);
  }
}

function createCityLevel() {
  scene.fog.color.setHex(0x001133);
  scene.background = new THREE.Color(0x000510);
  
  const floorMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.0, metalness: 0.8 });
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(100,100), floorMat);
  floor.rotation.x = -Math.PI/2;
  scene.add(floor); LEVEL_OBJECTS.push(floor);

  const rainGeo = new THREE.BufferGeometry();
  const rainPos = [];
  for(let i=0; i<2000; i++) {
    rainPos.push((Math.random()-0.5)*100, Math.random()*50, (Math.random()-0.5)*100);
  }
  rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(rainPos, 3));
  const rainMat = new THREE.PointsMaterial({ color: 0x00aaff, size: 0.2, transparent: true, opacity: 0.6 });
  const rain = new THREE.Points(rainGeo, rainMat);
  scene.add(rain); LEVEL_OBJECTS.push(rain);
  
  const bGeo = new THREE.BoxGeometry(5, 20, 5);
  const bMat = new THREE.MeshStandardMaterial({ color: 0x050510, roughness: 0.1, metalness: 0.8 });
  for(let i=0; i<30; i++) {
    const b = new THREE.Mesh(bGeo, bMat);
    b.position.set((Math.random()-0.5)*80, 10, (Math.random()-0.5)*80);
    scene.add(b); LEVEL_OBJECTS.push(b);
  }
}

function createAsteroidLevel() {
  scene.fog.color.setHex(0x331100);
  scene.background = new THREE.Color(0x100500);
  
  const grid = new THREE.GridHelper(80, 20, 0xff4400, 0x220000);
  scene.add(grid); LEVEL_OBJECTS.push(grid);
  
  const rockGeo = new THREE.DodecahedronGeometry(3);
  const rockMat = new THREE.MeshStandardMaterial({ color: 0x552200, flatShading: true });
  for(let i=0; i<20; i++) {
    const r = new THREE.Mesh(rockGeo, rockMat);
    r.position.set((Math.random()-0.5)*70, 1.5, (Math.random()-0.5)*70);
    r.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
    scene.add(r); LEVEL_OBJECTS.push(r);
  }
  
  const lavaLight = new THREE.PointLight(0xff4400, 2, 50);
  lavaLight.position.set(0, -2, 0);
  scene.add(lavaLight); LEVEL_OBJECTS.push(lavaLight);
}

// --- PARTICLES ---
function spawnParticle(pos, color, scale=0.5) {
  const geo = new THREE.TetrahedronGeometry(scale);
  const mat = new THREE.MeshBasicMaterial({ color: color });
  const p = new THREE.Mesh(geo, mat);
  p.position.copy(pos);
  p.userData = {
    vel: new THREE.Vector3((Math.random()-0.5)*0.5, Math.random()*0.5, (Math.random()-0.5)*0.5),
    life: 1.0
  };
  scene.add(p);
  PARTICLES.push(p);
}

function createExplosion(pos, color, count) {
  Sound.explosion();
  for(let i=0; i<count; i++) {
    spawnParticle(pos, color, Math.random()*0.5 + 0.2);
  }
}

// --- CORE LOGIC ---

const keys = {};
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

const getInpP1 = () => ({ up: keys['KeyW'], down: keys['KeyS'], left: keys['KeyA'], right: keys['KeyD'], fire: keys['Space'] });
const getInpP2 = () => ({ up: keys['ArrowUp'], down: keys['ArrowDown'], left: keys['ArrowLeft'], right: keys['ArrowRight'], fire: keys['Enter'] });

let lastShot = [0, 0];

function update(dt) {
  if(!GAME.active) return;

  if(!PLAYERS[0].dead) {
    PLAYERS[0].update(dt, getInpP1());
    if(getInpP1().fire && Date.now() > lastShot[0]) {
      shoot(PLAYERS[0]); lastShot[0] = Date.now() + 150;
    }
  }
  if(PLAYERS[1] && !PLAYERS[1].dead) {
    PLAYERS[1].update(dt, getInpP2());
    if(getInpP2().fire && Date.now() > lastShot[1]) {
      shoot(PLAYERS[1]); lastShot[1] = Date.now() + 150;
    }
  }

  for(let i=BULLETS.length-1; i>=0; i--) {
    const b = BULLETS[i];
    b.mesh.position.add(b.vel);
    if(Math.random() > 0.5) spawnParticle(b.mesh.position, b.color, 0.1);

    if(Math.abs(b.mesh.position.x) > 50 || Math.abs(b.mesh.position.z) > 50) {
      scene.remove(b.mesh); BULLETS.splice(i,1); continue;
    }

    for(let j=ENEMIES.length-1; j>=0; j--) {
      if(b.mesh.position.distanceTo(ENEMIES[j].mesh.position) < 2) {
        createExplosion(ENEMIES[j].mesh.position, 0xffaa00, 5);
        scene.remove(ENEMIES[j].mesh); ENEMIES.splice(j,1);
        GAME.score += 100;
        scene.remove(b.mesh); BULLETS.splice(i,1);
        break;
      }
    }
    
    if(GAME.mode === 2) {
      const target = PLAYERS.find(p => p.id !== b.ownerId && !p.dead);
      if(target && b.mesh.position.distanceTo(target.mesh.position) < 2) {
        target.takeDamage(10);
        scene.remove(b.mesh); BULLETS.splice(i,1);
      }
    }
  }

  ENEMIES.forEach(e => e.update(dt));
  if(Math.random() < 0.02 && ENEMIES.length < 8) ENEMIES.push(new Enemy());

  for(let i=PARTICLES.length-1; i>=0; i--) {
    const p = PARTICLES[i];
    p.position.add(p.userData.vel);
    p.userData.vel.y -= 0.02;
    p.userData.life -= 0.02;
    p.scale.setScalar(p.userData.life);
    p.rotation.x += 0.1;
    if(p.userData.life <= 0) { scene.remove(p); PARTICLES.splice(i,1); }
  }

  if(GAME.levelIdx === 0) { 
    LEVEL_OBJECTS.forEach(obj => {
      if(obj.geometry && obj.geometry.type === 'BoxGeometry') {
         obj.position.y = 2 + Math.sin(Date.now() * obj.userData.speed + obj.userData.offset) * 1;
      }
    });
  } else if (GAME.levelIdx === 1) { 
    const rain = LEVEL_OBJECTS.find(o => o instanceof THREE.Points);
    if(rain) {
      const pos = rain.geometry.attributes.position.array;
      for(let i=1; i<pos.length; i+=3) {
        pos[i] -= 2;
        if(pos[i] < 0) pos[i] = 50;
      }
      rain.geometry.attributes.position.needsUpdate = true;
    }
  } else if (GAME.levelIdx === 2) { 
    const light = LEVEL_OBJECTS.find(o => o instanceof THREE.PointLight);
    if(light) {
       light.intensity = 2 + Math.sin(Date.now() * 0.005) * 1;
    }
  }

  drawRadar();
  updateHUD();
}

function shoot(player) {
  Sound.shoot();
  const bMesh = new THREE.Mesh(
    new THREE.SphereGeometry(0.3), 
    new THREE.MeshBasicMaterial({ color: player.color })
  );
  bMesh.position.copy(player.mesh.position);
  bMesh.position.y += 1.5;
  const dir = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), player.mesh.rotation.y);
  scene.add(bMesh);
  BULLETS.push({ mesh: bMesh, vel: dir.multiplyScalar(1.5), color: player.color, owner: player.id });
}

function updateHUD() {
  document.getElementById('p1-hp').style.width = PLAYERS[0].hp + '%';
  if(PLAYERS[1]) document.getElementById('p2-hp').style.width = PLAYERS[1].hp + '%';
}

function drawRadar() {
  const cvs = document.getElementById('radar-canvas');
  const ctx = cvs.getContext('2d');
  ctx.clearRect(0,0,200,200);
  ctx.strokeStyle = 'rgba(0,255,0,0.2)';
  ctx.beginPath(); ctx.arc(100,100,90,0,Math.PI*2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(100,0); ctx.lineTo(100,200); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,100); ctx.lineTo(200,100); ctx.stroke();

  const scale = 2.5;
  PLAYERS.forEach(p => {
    if(!p.dead) {
      ctx.fillStyle = p.id===0 ? '#0ff' : '#f00';
      ctx.beginPath();
      ctx.arc(100 + p.mesh.position.x*scale, 100 + p.mesh.position.z*scale, 4, 0, Math.PI*2);
      ctx.fill();
    }
  });
  ctx.fillStyle = 'rgba(255,0,0,0.5)';
  ENEMIES.forEach(e => {
    ctx.beginPath();
    ctx.arc(100 + e.mesh.position.x*scale, 100 + e.mesh.position.z*scale, 2, 0, Math.PI*2);
    ctx.fill();
  });
}

// --- INIT & MENU ---

window.setLevel = (idx, el) => {
  GAME.levelIdx = idx;
  document.querySelectorAll('.level-opt').forEach(o => o.classList.remove('active'));
  el.classList.add('active');
};

window.startGame = (mode) => {
  GAME.mode = mode;
  GAME.active = true;
  GAME.score = 0;
  
  // Hide Menu, Show HUD
  document.getElementById('menu-screen').style.opacity = 0;
  setTimeout(() => document.getElementById('menu-screen').style.display = 'none', 500);
  document.getElementById('game-ui').style.display = 'block';
  if(audioCtx.state === 'suspended') audioCtx.resume();

  clearLevel();
  if(GAME.levelIdx === 0) { createNebulaLevel(); document.getElementById('level-ind').innerText = "SECTOR: NEBULA"; }
  else if(GAME.levelIdx === 1) { createCityLevel(); document.getElementById('level-ind').innerText = "SECTOR: CYBER CITY"; }
  else { createAsteroidLevel(); document.getElementById('level-ind').innerText = "SECTOR: ASTEROID BELT"; }

  PLAYERS.forEach(p => scene.remove(p.mesh));
  PLAYERS.length = 0;
  
  PLAYERS.push(new Player(0, 0x00ffff, new THREE.Vector3(0,0,20)));
  if(mode === 2) {
    PLAYERS.push(new Player(1, 0xff0000, new THREE.Vector3(5,0,20)));
    document.getElementById('p2-hud-container').style.display = 'flex';
  } else {
    document.getElementById('p2-hud-container').style.display = 'none';
  }

  const notify = document.getElementById('center-notify');
  notify.innerText = "COMBAT STARTED";
  notify.style.opacity = 1;
  setTimeout(() => notify.style.opacity = 0, 2000);
};

// Render Loop
const clock = new THREE.Clock();
function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  const time = Date.now() * 0.001;

  update(dt);

  // --- MENU ANIMATION ---
  if(!GAME.active) {
    // Rotate the Quantum Core
    menuCore.rotation.x = time * 0.5;
    menuCore.rotation.y = time * 0.3;
    
    // Pulse effect
    const scale = 1 + Math.sin(time * 2) * 0.1;
    menuCore.scale.set(scale, scale, scale);

    // Drift Camera in Menu
    camera.position.x = Math.sin(time * 0.1) * 20;
    camera.position.z = 20 + Math.cos(time * 0.1) * 10;
    camera.position.y = 5 + Math.sin(time * 0.2) * 2;
    camera.lookAt(0, 0, 0);
    
    // Keep Background Particles moving
    const positions = stars.geometry.attributes.position.array;
    for(let i=1; i<positions.length; i+=3) {
        positions[i] -= 0.05;
        if(positions[i] < -50) positions[i] = 50;
    }
    stars.geometry.attributes.position.needsUpdate = true;

    // Update Fog for Menu (Nebula Look)
    scene.fog.color.setHex(0x110022);
    scene.background = new THREE.Color(0x050010);
  } 
  // --- GAME CAMERA LOGIC ---
  else {
    // Lerp to Game View
    const targetPos = new THREE.Vector3(0, 35, 35);
    camera.position.lerp(targetPos, 0.05);
    camera.lookAt(0, 0, 0);
  }

  composer.render();
}

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
});

animate();

</script>
</body>
</html>
