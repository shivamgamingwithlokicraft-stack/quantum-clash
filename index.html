<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>QuantumClash 3D - Fixed</title>
<link rel="icon" href="https://cdn-icons-png.flaticon.com/512/616/616408.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body { margin:0; overflow:hidden; background:#111; font-family:Arial; }
header { position:fixed; top:0; width:100%; padding:10px; background:#0ff; text-align:center; font-weight:bold; z-index:10; color:#000; text-transform:uppercase; letter-spacing:2px;}
#ui { position:fixed; top:60px; left:10px; color:#0ff; z-index:10; text-shadow: 1px 1px 0 #000; font-size:14px; }
#mobile {
  position:fixed; bottom:20px; width:100%; display:flex;
  justify-content:space-around; z-index:20; pointer-events: none; /* Let clicks pass through around buttons */
}
.btn {
  background:rgba(0, 255, 255, 0.2); border: 2px solid #0ff; color:#0ff; padding:15px;
  border-radius:50%; font-weight:bold; pointer-events: auto; cursor: pointer;
  width: 60px; height: 60px; display: flex; align-items: center; justify-content: center;
  font-size: 20px; user-select: none;
  backdrop-filter: blur(4px);
}
.btn:active { background:#0ff; color:#000; }
</style>
</head>

<body>
<header>QuantumClash 3D</header>

<div id="ui">
  <div id="score" style="font-size: 1.2em; margin-bottom: 5px;">Score: 0</div>
  <div id="p1">Player Health: 100</div>
  <div id="boss" style="color:#f00; margin-top:5px;">Boss Health: 200</div>
</div>

<div id="mobile">
  <div class="btn" id="left">â—€</div>
  <div class="btn" id="shoot">ðŸ”¥</div>
  <div class="btn" id="right">â–¶</div>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157/build/three.module.js';

/* ===== SCENE ===== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050510); // Darker, space-like background
scene.fog = new THREE.Fog(0x050510, 20, 80);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0,15,35);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

/* ===== LIGHTS ===== */
const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(10,20,10);
dirLight.castShadow = true;
scene.add(dirLight);

// Neon glowing lights for aesthetics
const blueLight = new THREE.PointLight(0x00ffff, 2, 50);
blueLight.position.set(-10, 5, -10);
scene.add(blueLight);

const redLight = new THREE.PointLight(0xff0000, 2, 50);
redLight.position.set(10, 5, -20);
scene.add(redLight);

/* ===== FLOOR ===== */
const gridHelper = new THREE.GridHelper(100, 50, 0x00ffff, 0x222222);
scene.add(gridHelper);

const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(100,100),
  new THREE.MeshStandardMaterial({color:0x111111, roughness:0.8, metalness:0.2})
);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

/* ===== HELPER: CREATE ROBOT (Procedural Model) ===== */
// This replaces the GLTFLoader to ensure characters always show up
function createRobot(color, scale = 1) {
  const group = new THREE.Group();

  // Material
  const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3 });
  const darkMat = new THREE.MeshStandardMaterial({ color: 0x333333 });

  // Body
  const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 0.6), mat);
  body.position.y = 1.5;
  body.castShadow = true;
  group.add(body);

  // Head
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), darkMat);
  head.position.y = 2.6;
  group.add(head);

  // Eyes (Glowing)
  const eyeGeo = new THREE.BoxGeometry(0.5, 0.1, 0.1);
  const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); // Glowing look
  const eyes = new THREE.Mesh(eyeGeo, eyeMat);
  eyes.position.set(0, 2.6, 0.36);
  group.add(eyes);

  // Shoulders/Arms (Simple blocks)
  const armL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1, 0.4), darkMat);
  armL.position.set(-0.7, 1.5, 0);
  group.add(armL);
  const armR = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1, 0.4), darkMat);
  armR.position.set(0.7, 1.5, 0);
  group.add(armR);

  group.scale.set(scale, scale, scale);
  return group;
}

/* ===== GAME VARIABLES ===== */
const bullets = [];
const enemies = [];
const particles = []; // For explosion effects

let player1, boss;
let score=0, playerHealth=100, bossHealth=200;
let isGameOver = false;

/* ===== INITIALIZATION ===== */
// Create Player
player1 = createRobot(0x00ffff, 2); // Cyan Player
player1.position.set(0,0,10);
scene.add(player1);

// Create Boss
boss = createRobot(0xff0000, 4); // Red Boss
boss.position.set(0,0,-20);
scene.add(boss);

/* ===== BULLET SYSTEM ===== */
function createBullet(position, isPlayer) {
  const geo = new THREE.SphereGeometry(0.4);
  const mat = new THREE.MeshBasicMaterial({ color: isPlayer ? 0xffff00 : 0xff00ff });
  const b = new THREE.Mesh(geo, mat);
  
  b.position.copy(position);
  b.position.y += 1.5; // Adjust height to shoot from chest
  
  // Add velocity property
  b.userData = { 
    velocity: new THREE.Vector3(0, 0, isPlayer ? -1.5 : 1.0), // Player shoots -Z, Enemy shoots +Z
    isPlayer: isPlayer
  };
  
  scene.add(b);
  bullets.push(b);
}

/* ===== PARTICLE SYSTEM (Explosions) ===== */
function createExplosion(position, color) {
  for(let i=0; i<8; i++) {
    const geo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
    const mat = new THREE.MeshBasicMaterial({ color: color });
    const p = new THREE.Mesh(geo, mat);
    p.position.copy(position);
    
    // Random explosion velocity
    p.userData = {
      velocity: new THREE.Vector3(
        (Math.random()-0.5)*0.5,
        (Math.random())*0.5,
        (Math.random()-0.5)*0.5
      ),
      life: 1.0 // 1 second life
    };
    scene.add(p);
    particles.push(p);
  }
}

/* ===== SPAWNING ===== */
setInterval(()=>{
  if(isGameOver || !boss) return;
  
  // Spawn Minion
  const e = createRobot(0xff8800, 1.5);
  e.position.set(Math.random()*30-15, 0, -35); // Spawn far away
  scene.add(e);
  enemies.push(e);
}, 2000); // Spawn every 2 seconds

/* ===== BOSS AI ===== */
let lastBossShot = 0;
function bossAI(time){
  if(!boss || isGameOver) return;
  
  // Move side to side
  boss.position.x = Math.sin(time * 0.001) * 10;
  
  // Shoot occasionally
  if(time - lastBossShot > 1000) { // Shoot every 1 second
    createBullet(boss.position, false);
    lastBossShot = time;
  }
}

/* ===== UPDATE LOOP ===== */
const clock = new THREE.Clock();

function animate(){
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  const time = Date.now();

  if(isGameOver) return; // Stop game logic if over

  bossAI(time);

  // Idle Animation for Player (Bobbing)
  if(player1) player1.position.y = Math.sin(time * 0.005) * 0.2;
  
  // Bullets Update
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.position.add(b.userData.velocity);

    // Remove if too far
    if (b.position.z < -50 || b.position.z > 50) {
      scene.remove(b);
      bullets.splice(i, 1);
      continue;
    }

    // Collision Detection
    if (b.userData.isPlayer) {
      // Player bullet hitting Enemies
      let hit = false;
      
      // Check Boss
      const distBoss = b.position.distanceTo(boss.position);
      if (distBoss < 2.5) { // Simple radius check
        bossHealth -= 5;
        createExplosion(b.position, 0xff0000);
        hit = true;
        if(bossHealth <= 0) endGame(true);
      }
      
      // Check Minions
      if (!hit) {
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          if (b.position.distanceTo(e.position) < 1.5) {
            createExplosion(e.position, 0xff8800);
            scene.remove(e);
            enemies.splice(j, 1);
            score += 100;
            hit = true;
            break;
          }
        }
      }

      if (hit) {
        scene.remove(b);
        bullets.splice(i, 1);
      }
    } else {
      // Enemy bullet hitting Player
      if (b.position.distanceTo(player1.position) < 1.5) {
        playerHealth -= 10;
        createExplosion(player1.position, 0x00ffff);
        scene.remove(b);
        bullets.splice(i, 1);
        if(playerHealth <= 0) endGame(false);
      }
    }
  }

  // Enemies Update (Move towards player)
  enemies.forEach((e, i) => {
    e.position.z += 0.1; // Move forward
    e.lookAt(player1.position); // Face player
    // Bobbing animation
    e.children[0].rotation.x = Math.sin(time * 0.01 + i) * 0.1; 

    if (e.position.distanceTo(player1.position) < 1.5) {
      playerHealth -= 1; // Contact damage
      scene.remove(e);
      enemies.splice(i, 1);
    }
  });

  // Particles Update
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.position.add(p.userData.velocity);
    p.userData.velocity.y -= 0.02; // Gravity
    p.userData.life -= 0.05;
    p.scale.setScalar(p.userData.life);
    
    if(p.userData.life <= 0 || p.position.y < 0) {
      scene.remove(p);
      particles.splice(i, 1);
    }
  }

  updateUI();
  renderer.render(scene,camera);
}

/* ===== UI UPDATES ===== */
function updateUI() {
  document.getElementById("score").textContent = "Score: "+score;
  document.getElementById("p1").textContent = "Player Health: "+playerHealth;
  document.getElementById("boss").textContent = "Boss Health: "+bossHealth;
}

function endGame(victory) {
  isGameOver = true;
  const header = document.querySelector("header");
  if(victory) {
    header.textContent = "VICTORY! BOSS DESTROYED";
    header.style.background = "#0f0";
  } else {
    header.textContent = "GAME OVER - TRY AGAIN";
    header.style.background = "#f00";
  }
}

/* ===== CONTROLS ===== */
function movePlayer(dir) {
  if(!player1 || isGameOver) return;
  player1.position.x += dir;
  // Clamp position
  player1.position.x = Math.max(-14, Math.min(14, player1.position.x));
}

// Keyboard
window.addEventListener("keydown", (e) => {
  if(e.key === "ArrowLeft") movePlayer(-2);
  if(e.key === "ArrowRight") movePlayer(2);
  if(e.code === "Space") createBullet(player1.position, true);
});

// Mobile
const leftBtn = document.getElementById("left");
const rightBtn = document.getElementById("right");
const shootBtn = document.getElementById("shoot");

leftBtn.ontouchstart = (e) => { e.preventDefault(); movePlayer(-2); };
rightBtn.ontouchstart = (e) => { e.preventDefault(); movePlayer(2); };
shootBtn.ontouchstart = (e) => { e.preventDefault(); createBullet(player1.position, true); };

// Mouse Click fallback for shooting
window.addEventListener("mousedown", () => {
  if(!isGameOver && document.pointerType === '') createBullet(player1.position, true);
});

/* ===== RESIZE ===== */
addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});

// Start Loop
animate();
</script>
</body>
</html>
